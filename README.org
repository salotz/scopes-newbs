* Scopes Programming Language for Scripting Language Users (AKA newbs)

- Homepage :: [[http://scopes.rocks]]
- Project Repository :: https://hg.sr.ht/~duangle/scopes
- Documentation :: https://scopes.readthedocs.io/en/latest/

Some projects & repos using Scopes. These are very useful due to
sparse documentation:

- Tukan Media Library & Visual Game Engine :: https://hg.sr.ht/~duangle/tukan
- Metroidvania Game :: https://github.com/radgeRayden/metroidvania
- Bottle :: https://github.com/radgeRayden/bottle
- Radlib: Some helper libraries WIP :: https://github.com/radgeRayden/radlib
- Experimental Lisp on Scopes :: https://github.com/radgeRayden/rl
- Scope Snippets :: https://github.com/radgeRayden/scopes-snippets
- Definition of Scopes Symbols :: https://github.com/radgeRayden/scopes-std-symbols

** Prelude

*** Source Code

Scopes programs are text files ending with the file extension ~.sc~.

The "format" of these files is independent of the language and is
called "Scopes List Notation" (SLN). Its equivalent to writing a
programming language in XML, JSON or YAML syntax.

In this format words are separated by either whitespace, parentheses
~()~ (or brackets too if you want ~[]{}~), and
newlines-followed-by-indentation (i.e. python style).

Some examples of SLN that are not scopes code but are all equivalent:

#+begin_src scopes
  person
      first_name Bob
      last_name Bobson
#+end_src

#+begin_src scopes
  person (first_name Bob) (last_name Bobson)
#+end_src

The full description is in the documentation. Don't get too caught up
in the details. If you get stuck with the indentation method just
throw parentheses around everything and work your way back.

Comments are lines and indentation blocks starting with a ~#~. Symbols
are not part of the parse tree.

The ~;~ and ~,~ characters are also reserved by the SLN syntax, but
this author doesn't think they are necessary to understand and write
the code. They are more used to get around a few gnarly parts of the
space and parens syntax or just to make a few things nicer.

The ~;~ is the "list separator" and is similar to the "statement
separator" of imperative languages like C/C++. In Python this would
just be the "newline" of having commands run in order, for which the
~;~ character can also be used to put them on a single line.

The ~,~ character is a list separator which can be used without
whitespace (or with too..) (see Lists section)

There are 5 types of elements in SLN which will be discussed more in
the primitives section.

- Numbers
- Strings
- Symbols
- Lists
- Comments

*** Running Programs

If you have a file you can run it on the command line like:

#+begin_src sh
scopes file.sc
#+end_src

You can also use the interpreter (typically called a REPL):

#+begin_src sh
scopes
#+end_src

On the REPL the help command can tell you the signature of functions,
where you can see for yourself:

#+begin_src scopes
  help print
#+end_src

*** Some Things to Keep in Mind

**** Keywords & Symbols

In scopes there are no proper "keywords" like in most languages in the
sense that there is a compiler or interpreter that is hardcoded to
understand certain words as special. In this document we may say
"keyword" to not overcomplicate things, but just keep that in mind for
when approaching the more advanced features.

# TODO: explain symbols


**** Style Choices

I don't pay attention too much to style here except that it should
look decent and be easy to copy-paste into REPL in one line if
possible.


** Level 1: What you already know, just Scoped

In this section we will cover the concepts that are basically the same
between a scripting language like Python and Scopes.

*** Printing Output

What language is complete without a print statement!

#+begin_src scopes :tangle _bin/print1.sc
  print "Hello World!"
#+end_src

The print statement takes a variable number of arguments, just like in
Python:

#+begin_src scopes :tangle _bin/print2.sc
  # print with 2 arguments
  print "Hello" "World!"
#+end_src

Here the basic string type is used. We will describe strings in more
detail later.

We also show the use of comments in the last example

*** Primitives & Simple Expressions

**** Overview

Overview:

| Type                  | Type Symbols                              | Example                                        |
|-----------------------+-------------------------------------------+------------------------------------------------|
| Boolean               | ~bool~                                    | ~true~, ~false~                                |
| Integer               | ~i32~ (default), ~i8~, ~i16~, ~i64~       | ~1~, ~-4~, ~+7~, ~3:i8~, ~0x20~                |
| Unsigned Integer      | ~u8~, ~u16~, ~u32~, ~u64~                 | ~3:u64~                                        |
| Floating Point Number | ~f32~ (default), ~f64~ (double precision) | ~1.~, ~1.0~, ~3.456:f64~, ~nan~, ~inf~, ~1e12~ |
| Empty Signifier       | ~Nothing~                                 | ~none~                                         |
| Null Pointer          | ~NullType~                                | ~null~                                         |
| Fixed-lengthString    | ~string~                                  | ~"hello"~                                      |
| Lists                 | ~List~                                    | ~'()~, ~'("a" true 1)~, ~'[0 1]~, ~{3; 1 }~    |

Note that you can determine the type of a value with the ~typeof~
function:

#+begin_src scopes :tangle _bin/primitives_typeof.sc
typeof true
typeof 1
typeof 1.0
typeof none
typeof null

let hello_type = (typeof "hello")
print "string type:" hello_type

typeof 'something
typeof '()
#+end_src

Here we can see use of the 3 different primitive syntax units in SLN
notation and how they map to the primitive values in the Scopes
language.

- ~typeof~, ~true~, ~null~, ~none~, and ~'something~ are all symbols
- ~1~ and ~1.0~ are numbers
- ~"hello"~ is a string
- ~'()~ is a list

**** Special Values

There are a few special values defined in the core language:

- ~none~ :: Which signifies emptiness and uses no storage.
- ~null~ :: Which is similar to a null-pointer and is used for pointer
  comparisons.

**** Booleans

The two primitive boolean values are given by the two symbols ~true~
and ~false~.

Like in Python other values can be interpreted implicitly as
booleans. This will be discussed in the sections for each primitive.

We have simple boolean logical operators in ~or~ and ~and~:

#+begin_src scopes :tangle _bin/primitives_bool.sc
true and false
true or true
#+end_src


**** Primitive Strings

Strings are anything surrounded by double-quotes ~"~. As we have
already seen:

#+begin_src scopes :tangle _bin/primitives_strings.sc
  print "a string"
  typeof "stringzz"
#+end_src

Multiline strings can be given with quadruple-double-quotes and then
continued using indentation adjusted up to the column after the
quadruple-double-quotes:

#+begin_src scopes :tangle _bin/primitives_strings.sc
  """"a multiline string
      That is continued here
      Thats 4 (four) double-"quotes"
#+end_src

Note you don't need to escape the double-quotes in the block since
multiline blocks are considered "raw", unlike single line strings
where double-quotes need to be escaped:

#+begin_src scopes :tangle _bin/primitives_strings.sc
  print "The man said \"hello\""
#+end_src

Note that unlike languages like Python single quotes (~'~) cannot be used
for delimiting strings like double-quotes (~"~).


#+begin_src scopes :tangle _bin/primitives_strings.sc
  let multiline = """"a multiline string
                      That is continued here
                      Thats 4 (four) double-quotes

  print multiline
#+end_src

For instance this will raise an error:

#+begin_src scopes
  let multiline = """"a multiline string
      That is continued here
      Thats 4 (four) double-quotes
#+end_src

To join strings together you can use the ~..~ operator:

#+begin_src scopes :tangle _bin/primitives_strings.sc

  let header = ("Hello" .. " There:")

  print (header .. " Bob")
#+end_src

You can get the number of characters in a string with the ~countof~
function:

#+begin_src scopes :tangle _bin/primitives_strings.sc
  let alphabet = "abcdefghijklmnopqrstuvwxyz"

  print (countof alphabet)
#+end_src

There are also some slice routines:

- ~slice~ :: Get characters from start to end
- ~lslice~ :: Get characters to the left of an index
- ~rslice~ :: Get characters to the right of an index

#+begin_src scopes :tangle _bin/primitives_strings.sc
  print (slice alphabet 0 3)
  print (lslice alphabet 3)

  print (slice alphabet 3 (countof alphabet))
  print (rslice alphabet 3)
#+end_src

**** Integers & Unsigned Integers

While integers are familiar to Python programmers the family of
different types around them is unfamiliar. This is because Python
provides an idealized view of what an integer is. In lower level
languages like C/C++ and Scopes the underlying byte representation of
values is a first class concept, in order to be able to tightly
control memory usage for performant applications.

Additionally there is the concept of a signed and unsigned
integer. Using an unsigned integer frees up a bit that would normall
be taken up with information of the sign (i.e. positive or negative).

Signed integers are useful for arithmetic and numerical calculations
and unsigned integers are useful as indices and other identifiers that
you wouldn't perform arithmetic on.

Signed integers have type symbols of the form ~i<num_bits>~ and
unsigned integers of the form ~u<num_bits>~.

Where ~num_bits~ can be: ~8~, ~16~, ~32~, or ~64~.

For visual completeness:

| Num Bits | Signed | Unsigned |
|----------+--------+----------|
|        8 | ~i8~   | ~u8~     |
|       16 | ~i16~  | ~u16~    |
|       32 | ~i32~  | ~u32~    |
|       64 | ~i64~  | ~u64~    |

Numbers from SLN without a ~.~ are parsed as ~i32~ by default.

#+begin_src scopes :tangle _bin/primitives_integers.sc
  assert ((typeof 13) == i32)
#+end_src

The literal syntax for getting any type of number is the numerical
value syntax (e.g. ~3~) followed by ~:<type_symbol>~.

So that for the number ~8~ as an ~i8~ number you can write:

#+begin_src scopes :tangle _bin/primitives_integers.sc
  print 8:i8
#+end_src


**** Floating Point Numbers

Floating point numbers ("floats") are similar to integers in
syntax.

| Num Bits              | Symbol |
|-----------------------+--------|
| 32 (single precision) | ~f32~  |
| 64 (double precision) | ~f64~  |

Floats can be gotten from literals by adding a decimal notation or the
explicit annotation:

#+begin_src scopes :tangle _bin/primitives_floats.sc

  # integer
  typeof 1

  # floats
  typeof 1.
  typeof 1.0
  typeof 1:f32
  typeof 1:f64
#+end_src

~f32~ is the default for unannotated literals.

You can also use scientific notation equivalent to ~1*10^n~:

#+begin_src scopes :tangle _bin/primitives_floats.sc
  3e4
  typeof 3e4

  3e-4
  typeof 3e4
#+end_src

There are 3 special values for floating point numbers:

- ~+inf~ or ~inf~ :: positive "infinity"
- ~-inf~ :: negative "infinity"
- ~nan~ or ~-nan~ :: not a number

That have special relationships:

#+begin_src scopes :tangle _bin/primitives_floats.sc
  2. + inf
  2. * inf
  2. / inf
  inf / 2.

  2. // inf
  # be careful...
  inf // 2.

  2. + nan
  2. * nan
  2. / nan
  nan / 2.
  2. // nan
  # be careful...
  nan // 2.


  inf + inf
  inf * inf
  inf / inf
  inf // inf
  -inf + inf
  -inf * inf
  -inf / inf
  inf / -inf
  -inf // inf
#+end_src

The operators are described later in the arithmetic section but should
be obvious.


**** TODO Lists

#+begin_src scopes :tangle _bin/primitives_lists.sc
#+end_src


**** TODO Symbols

A full description of symbols will have to wait until level 2 as this
is Scheme territory. However we introduce them here since they are a
primitive.

Symbols are just everything that is not a number, string, or list (or
comment).

Symbols are what you assign values to:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  let my_symbol = 0
#+end_src

Here we are using a symbol syntax compatible with most other
programming languages (in Python this is called "snake case"). However
unlike other languages symbols have much more freedom in what their
syntax is. As long as a symbol can't be parsed as a number, string,
list, or comment it will be interpreted as a symbol. Also any of the
brackets or separator symbols are not allowed in symbols
(i.e. ~#;()[]{},~).

That means all of the following are valid:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  let =a-Symbol+for_you~ = 0

  let @begin = "itemize"

  let * = 4
  let two+two = 4
  let 2+2 = 4

  let `yes^you^can` = "but should you?"

  let valid? = false
  let !!important!! = "you are under arrest"

#+end_src

Symbols are kind of like strings in that they are a collection of
characters. You can even get the strings from them (see Casting below):

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  print ('valid? as string)
#+end_src

Notice the leading ~'~ of the symbol. This is a special language
construct which says I want the symbol itself and not the value it
represents.

Consider what happens without it:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  print (valid? as string)
#+end_src

And in fact you don't even need to have assigned something to a symbol
for it to "exist":

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  print ('IHaventBeenAssignedToYet as string)
#+end_src



*** TODO Arithmetic & Mathematics



**** TODO Special Mathematical Functions and Numbers

|   | symbol |
|---+--------|
|   | ~ln~   |
|   | ~pi~   |
|   | ~sin~  |
|   | ~cos~  |


*** Variable Assignment

Variables can be assigned to with the ~let~ keyword:

#+begin_src scopes :tangle _bin/assignment_let.sc
  let name = "Bob"
#+end_src

*** Basic Control Flow

**** Conditionals

Many languages have more advanced features where they let you use
things like "ternary operators" to assign to values based on a small
conditional. This is quite beautiful in scopes:

#+begin_src scopes :tangle _bin/conditional_assignment.sc
  let b = 10
  let a =
      if (b < 100)
          b
      else
          100
  print a
#+end_src


**** Loops

The fundamental loop in scopes is very general, but maybe not exactly
what you are used to from a langauge like Python.

Scopes does provide these comfy loops though and its very satisfying.

***** For-Loop

Here is a basic for loop like you would find in python:

#+begin_src scopes :tangle _bin/loop_range-forloop.sc
  for i in (range 10)
      print i
#+end_src


You can loop over the language level lists, but they need to be
"quoted" by placing a single apostrophe ~'~ at the beginning of the
list just like in other Scheme languages. Otherwise it will try to
call the function ~0~ on arguments ~1~ and ~2~.

#+begin_src scopes :tangle _bin/loop_forloop.sc
  for i in '(0 1 2)
      print i
#+end_src

***** While-Loop

#+begin_src scopes :tangle _bin/loop_whileloop.sc
  local i = 0
  while (i < 5)
      print i
      i += 1
#+end_src


***** General Loop

The general loop has a few more requirements but is more flexible.

There should be:

1. A path to "repeat" the loop
2. A path to break out of the loop

#+begin_src scopes :tangle _bin/loop_loop-A.sc
  loop (a = 0)
      print a
      if (a < 10)
          repeat (a + 1)
      else
          break a
#+end_src


Technically the ~repeat~ is redundant and a bare value at the end of a
scope will "return" it and continue the loop.

#+begin_src scopes :tangle _bin/loop_loop-B.sc
  loop (a = 0)
      print a
      if (a < 10)
          a + 1
      else
          break a
#+end_src

You do need the break though, or it won't compile as this will always
be an infinite loop.


*** Type Casting

You can convert types using the ~as~ operator:

#+begin_src scopes :tangle _bin/typecast_as.sc
  # constant
  0 as f32

  1.2 as i32

  -1 as u32

  # not constant
  'a-symbol as string
#+end_src

Which is a *static cast* and happens at compile time (see caveats above).


TODO:

- ~imply~


*** Defining Functions

*** Modules

Scopes provides a module system very much like python.

You can import installed libraries and use their methods such as:

#+begin_src scopes :tangle _bin/modules_import.sc
  import String
  let str = (String.String "hello")
#+end_src

Or you can dump the exported symbols (i.e. functions and variables)
into your current namespace with the ~using~ keyword:

#+begin_src scopes :tangle _bin/modules_using-import.sc
  using import String
  let str = (String "hello")  
#+end_src

You can also directly bind a loaded module to a symbol:

#+begin_src scopes :tangle _bin/modules_using-import.sc
  let string_mod = (import String)
  let str = (string_mod.String "hello")  
#+end_src

TODO:

You can write a module like this in a file ~hellomod.sc~:

#+begin_src scopes :tangle _bin/hellomod.sc
  fn hello (name)
      (print "Hello" name)

  do
      let hello
      locals;
#+end_src

And then import it like:

#+begin_src scopes :tangle _bin/modules_load-local-module.sc
  let mod = (import .hellomod)

  hellomod.hello "Bob"
#+end_src

*** Errors & Assertions

**** Assertions

Scopes has the common assert function which you can use for quick
checks of boolean expressions:

#+begin_src scopes :tangle _bin/errors_assert.sc
  assert true

  assert not false

  assert (1 == 1)
#+end_src

This will raise an error:

#+begin_src scopes
  assert false
#+end_src

**** TODO Error Propagation

There is also the familiar ~raise~ and ~try~.

** Level 2: Things you would know if you knew C/C++

*** TODO More Strings

*** TODO Arrays


*** Including C Functions

You can load a single function:

#+begin_src scopes :tangle _bin/externc1.sc
  let printf =
      do
          let header = (include "stdio.h")
          header.extern.printf

  printf "hello\n"
#+end_src


Or a whole module:

#+begin_src scopes :tangle _bin/externc2.sc
  let std:io =
      (include "stdio.h") . extern

  std:io.printf "hello\n"
#+end_src

Note that ~std:io~ is just a symbol and not special syntax. It could
have been: ~stdio~ or any other valid symbol.


*** TODO Pattern Matching

See ~match~


** Level 3: For Lisp/Scheme Gurus

In this section we will cover the features that are similar to Lisp
and Scheme like languages.

Scopes is after all a Scheme-like language.


** Level 4: Going super-saiyan, Scopes trick-shots


** Level 5: ...
