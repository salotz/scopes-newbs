* Scopes Programming Language for Scripting Language Users (AKA newbs)

Testing:

#+begin_src scopes
print "hello"
#+end_src

#+RESULTS:
: hello

*** Official Resources

- Homepage :: [[http://scopes.rocks]]
- Project Repository :: https://hg.sr.ht/~duangle/scopes
- Documentation :: https://scopes.readthedocs.io/en/latest/


*** Helpful Links

Some projects & repos using Scopes. These are very useful due to
sparse documentation:

- Tukan Media Library & Visual Game Engine :: https://hg.sr.ht/~duangle/tukan
- Metroidvania Game :: https://github.com/radgeRayden/metroidvania
- Bottle :: https://github.com/radgeRayden/bottle
- Radlib: Some helper libraries WIP :: https://github.com/radgeRayden/radlib
- Experimental Lisp on Scopes :: https://github.com/radgeRayden/rl
- Scope Snippets :: https://github.com/radgeRayden/scopes-snippets
- Definition of Scopes Symbols :: https://github.com/radgeRayden/scopes-std-symbols

** Prelude

*** Source Code

Scopes programs are text files ending with the file extension ~.sc~.

The "format" of these files is independent of the language and is
called "Scopes List Notation" (SLN). Its equivalent to writing a
programming language in XML, JSON or YAML syntax.

In this format words are separated by either whitespace, parentheses
~()~ (or brackets too if you want ~[]{}~), and
newlines-followed-by-indentation (i.e. python style).

Some examples of SLN that are *NOT* Scopes code but are all equivalent:

#+begin_src scopes
  person
      first_name Bob
      last_name Bobson
#+end_src

#+begin_src scopes
  person (first_name Bob) (last_name Bobson)
#+end_src

The full description is in the documentation. Don't get too caught up
in the details. If you get stuck with the indentation method just
throw parentheses around everything and work your way back.

Comments are lines and indentation blocks starting with a ~#~. Symbols
are not part of the parse tree.

The ~;~ and ~,~ characters are also reserved by the SLN syntax, but
this author doesn't think they are necessary to understand and write
the code. They are more used to get around a few gnarly parts of the
space and parens syntax or just to make a few things nicer.

The ~;~ is the "list separator" and is similar to the "statement
separator" of imperative languages like C/C++. In Python this would
just be the "newline" of having commands run in order, for which the
~;~ character can also be used to put them on a single line.

The ~,~ character is a list separator which can be used without
whitespace (or with too..) (see Lists section)

There are 5 types of elements in SLN which will be discussed more in
the primitives section.

- Numbers
- Strings
- Symbols
- Lists
- Comments

*** Running Programs

If you have a file you can run it on the command line like:

#+begin_src sh
scopes file.sc
#+end_src

You can also use the interpreter (typically called a REPL):

#+begin_src sh
scopes
#+end_src

On the REPL the help command can tell you the signature of functions,
where you can see for yourself:

#+begin_src scopes
  help print
#+end_src

You can also run shell commands with the ~sh~ command:

#+begin_src scopes
  sh ls
#+end_src

*** Some Things to Keep in Mind

**** Keywords & Symbols

In scopes there are no proper "keywords" like in most languages in the
sense that there is a compiler or interpreter that is hardcoded to
understand certain words as special. In this document we may say
"keyword" to not overcomplicate things, but just keep that in mind for
when approaching the more advanced features.

**** Style Choices

I don't pay attention too much to style here except that it should
look decent and be easy to copy-paste into REPL in one line if
possible.


** Level 1: What you already know, just Scoped

In this section we will cover the concepts that are basically the same
between a scripting language like Python and Scopes.

*** Printing Output

What language is complete without a print statement!

#+begin_src scopes :tangle _bin/print1.sc
  print "Hello World!"
#+end_src

The print statement takes a variable number of arguments, just like in
Python:

#+begin_src scopes :tangle _bin/print2.sc
  # print with 2 arguments
  print "Hello" "World!"
#+end_src

Here the basic string type is used. We will describe strings in more
detail later.

We also show the use of comments in the last example


*** Variable Assignment & Binding

Variables can be assigned to with the ~let~ syntax:

#+begin_src scopes :tangle _bin/assignment_let.sc
  let name = "Bob"
#+end_src

Simple enough. As we will see once we learn about expressions though
that the right hand side can be much more complex than in most
languages.

For one we can do multiple assignments in the same let block:

#+begin_src scopes :tangle _bin/assignment_let.sc
  let
      name = "Bob"
      password = "password"
      height = 6
#+end_src



*** Operators

In most Lisp/Schemes there are no "operators" in the sense of infix
notations (i.e. ~arg1 operator arg2~) and only a uniform prefix
notation (i.e. ~operator arg1 arg2~). Thus unifying operators and
functions.

For many things an infix operator is preferable because it mirrors the
common notations such as in mathematics.

In Scopes you can use both! And you can also overload operators
although we won't talk about that until Level 2.

We will take the ~+~ and ~*~ operators to demonstrate the point
(arithmetic and numbers described in detail below, but nothing here
should surprise you).

We start with an understandable arithmetic expression which is also
valid Scopes code. There is an order of operations but we write this
unambiguously for now:

#+begin_src scopes :tangle _bin/operators.sc
  (0 * 3) + (1 * (4 * 5))
#+end_src

The equivalent prefix code is:

#+begin_src scopes :tangle _bin/operators.sc
  (+ (* 0 3) (* 1 (* 4 5)))
#+end_src

One advantage of prefix code is that for infix expressions like:

#+begin_src scopes :tangle _bin/operators.sc
  1 + 2 + 3 + 4
#+end_src

You can write them more simply in a summation type notation:

#+begin_src scopes :tangle _bin/operators.sc
  (+ 1 2 3 4)
#+end_src

Functions in prefix notation are also more flexible when you get to
higher order functional programming.

*** Primitives & Simple Expressions

**** Overview

Overview:

| Type                  | Type Symbols                              | Example                                        |
|-----------------------+-------------------------------------------+------------------------------------------------|
| Boolean               | ~bool~                                    | ~true~, ~false~                                |
| Integer               | ~i32~ (default), ~i8~, ~i16~, ~i64~       | ~1~, ~-4~, ~+7~, ~3:i8~, ~0x20~                |
| Unsigned Integer      | ~u8~, ~u16~, ~u32~, ~u64~                 | ~3:u64~                                        |
| Floating Point Number | ~f32~ (default), ~f64~ (double precision) | ~1.~, ~1.0~, ~3.456:f64~, ~nan~, ~inf~, ~1e12~ |
| Empty Signifier       | ~Nothing~                                 | ~none~                                         |
| Null Pointer          | ~NullType~                                | ~null~                                         |
| Fixed-lengthString    | ~string~                                  | ~"hello"~                                      |
| Lists                 | ~List~                                    | ~'()~, ~'("a" true 1)~, ~'[0 1]~, ~{3; 1 }~    |

Note that you can determine the type of a value with the ~typeof~
function:

#+begin_src scopes :tangle _bin/primitives_typeof.sc
typeof true
typeof 1
typeof 1.0
typeof none
typeof null

let hello_type = (typeof "hello")
print "string type:" hello_type

typeof 'something
typeof '()
#+end_src

Here we can see use of the 3 different primitive syntax units in SLN
notation and how they map to the primitive values in the Scopes
language.

- ~typeof~, ~true~, ~null~, ~none~, and ~'something~ are all symbols
- ~1~ and ~1.0~ are numbers
- ~"hello"~ is a string
- ~'()~ is a list

**** Special Values

There are a few special values defined in the core language:

- ~none~ :: Which signifies emptiness and uses no storage.
- ~null~ :: Which is similar to a null-pointer and is used for pointer
  comparisons.

**** Booleans

The two primitive boolean values are given by the two symbols ~true~
and ~false~.

We have simple boolean logical operators in ~and~, ~or~, and ~not~:

#+begin_src scopes :tangle _bin/primitives_bool.sc
true and false
true or true
not true
#+end_src


Similar to Python other values can be interpreted implicitly as
booleans, however unlike in Python not all of them can do this.

#+begin_src scopes :tangle _bin/primitives_bool.sc
not 0
not 1

#+end_src


**** Primitive Strings

Strings are anything surrounded by double-quotes ~"~. As we have
already seen:

#+begin_src scopes :tangle _bin/primitives_strings.sc
  print "a string"
  typeof "stringzz"
#+end_src

Multiline strings can be given with quadruple-double-quotes and then
continued using indentation adjusted up to the column after the
quadruple-double-quotes:

#+begin_src scopes :tangle _bin/primitives_strings.sc
  """"a multiline string
      That is continued here
      Thats 4 (four) double-"quotes"
#+end_src

Note you don't need to escape the double-quotes in the block since
multiline blocks are considered "raw", unlike single line strings
where double-quotes need to be escaped:

#+begin_src scopes :tangle _bin/primitives_strings.sc
  print "The man said \"hello\""
#+end_src

Note that unlike languages like Python single quotes (~'~) cannot be used
for delimiting strings like double-quotes (~"~).


#+begin_src scopes :tangle _bin/primitives_strings.sc
  let multiline = """"a multiline string
                      That is continued here
                      Thats 4 (four) double-quotes

  print multiline
#+end_src

For instance this will raise an error:

#+begin_src scopes
  let multiline = """"a multiline string
      That is continued here
      Thats 4 (four) double-quotes
#+end_src

To join strings together you can use the ~..~ operator:

#+begin_src scopes :tangle _bin/primitives_strings.sc

  let header = ("Hello" .. " There:")

  print (header .. " Bob")
#+end_src

You can get the number of characters in a string with the ~countof~
function:

#+begin_src scopes :tangle _bin/primitives_strings.sc
  let alphabet = "abcdefghijklmnopqrstuvwxyz"

  print (countof alphabet)
#+end_src

There are also some slice routines:

- ~slice~ :: Get characters from start to end
- ~lslice~ :: Get characters to the left of an index
- ~rslice~ :: Get characters to the right of an index

#+begin_src scopes :tangle _bin/primitives_strings.sc
  print (slice alphabet 0 3)
  print (lslice alphabet 3)

  print (slice alphabet 3 (countof alphabet))
  print (rslice alphabet 3)
#+end_src

**** Integers & Unsigned Integers

While integers are familiar to Python programmers the family of
different types around them is unfamiliar. This is because Python
provides an idealized view of what an integer is. In lower level
languages like C/C++ and Scopes the underlying byte representation of
values is a first class concept, in order to be able to tightly
control memory usage for performant applications.

Additionally there is the concept of a signed and unsigned
integer. Using an unsigned integer frees up a bit that would normall
be taken up with information of the sign (i.e. positive or negative).

Signed integers are useful for arithmetic and numerical calculations
and unsigned integers are useful as indices and other identifiers that
you wouldn't perform arithmetic on.

Signed integers have type symbols of the form ~i<num_bits>~ and
unsigned integers of the form ~u<num_bits>~.

Where ~num_bits~ can be: ~8~, ~16~, ~32~, or ~64~.

For visual completeness:

| Num Bits | Signed | Unsigned |
|----------+--------+----------|
|        8 | ~i8~   | ~u8~     |
|       16 | ~i16~  | ~u16~    |
|       32 | ~i32~  | ~u32~    |
|       64 | ~i64~  | ~u64~    |

Numbers from SLN without a ~.~ are parsed as ~i32~ by default.

#+begin_src scopes :tangle _bin/primitives_integers.sc
  assert ((typeof 13) == i32)
#+end_src

The literal syntax for getting any type of number is the numerical
value syntax (e.g. ~3~) followed by ~:<type_symbol>~.

So that for the number ~8~ as an ~i8~ number you can write:

#+begin_src scopes :tangle _bin/primitives_integers.sc
  print 8:i8
#+end_src


**** Floating Point Numbers

Floating point numbers ("floats") are similar to integers in
syntax.

| Num Bits              | Symbol |
|-----------------------+--------|
| 32 (single precision) | ~f32~  |
| 64 (double precision) | ~f64~  |

Floats can be gotten from literals by adding a decimal notation or the
explicit annotation:

#+begin_src scopes :tangle _bin/primitives_floats.sc

  # integer
  typeof 1

  # floats
  typeof 1.
  typeof 1.0
  typeof 1:f32
  typeof 1:f64
#+end_src

~f32~ is the default for unannotated literals.

You can also use scientific notation equivalent to ~1*10^n~:

#+begin_src scopes :tangle _bin/primitives_floats.sc
  3e4
  typeof 3e4

  3e-4
  typeof 3e4
#+end_src

There are 3 special values for floating point numbers:

- ~+inf~ or ~inf~ :: positive "infinity"
- ~-inf~ :: negative "infinity"
- ~nan~ or ~-nan~ :: not a number

That have special relationships (sorry went a little crazy with all of
the combinations):

#+begin_src scopes :tangle _bin/primitives_floats.sc
  2. + inf
  2. * inf
  2. / inf
  inf / 2.

  2. // inf
  # be careful...
  inf // 2.

  2. + nan
  2. * nan
  2. / nan
  nan / 2.
  2. // nan
  # be careful...
  nan // 2.


  inf + inf
  inf * inf
  inf / inf
  inf // inf
  -inf + inf
  -inf * inf
  -inf / inf
  inf / -inf
  -inf // inf
#+end_src

The operators are described later in the arithmetic section but should
be obvious.


**** Symbols

***** Defining Symbols

A full description of symbols will have to wait until level 2 as this
is Scheme territory. However we introduce them here since they are a
primitive.

Symbols are just everything that is not a number, string, or list (or
comment).

Symbols are what you assign values to:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  let my_symbol = 0
#+end_src

Here we are using a symbol syntax compatible with most other
programming languages (in Python this is called "snake case"). However
unlike other languages symbols have much more freedom in what their
syntax is. As long as a symbol can't be parsed as a number, string,
list, or comment it will be interpreted as a symbol. Also any of the
brackets or separator symbols are not allowed in symbols
(i.e. ~#;()[]{},~ from the SLN definition).

Additionally the Scopes language adds some extra restrictions you will
notice for the ~'~ and ~`~ characters. We will see in a few places
where ~'~ (~sugar-quote~) gets used in this level, but it will be much
later that we encounter ~`~ (~spice-quote~).

That means all of the following are valid:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  let =a-Symbol+for_you~ = 0

  let @begin = "itemize"

  let * = 4
  let two+two = 4
  let 2+2 = 4

  let yes^you^can = "but should you?"

  let valid? = false
  let !!important!! = "you are under arrest"

#+end_src

However these will produce errors:

#+begin_src scopes
let 'hello = 0
let hell'o = 0
let hello' = 0

let `hello = 0
#+end_src

However the following are fine:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  let hel`lo` = 0
#+end_src

The reason for this is is so that Scopes can distinguish between the
value a symbol is bound to (like a variable name) and the structure of
the symbol itself (i.e. the characters in the symbol).

***** "Quoting" & Symbols

This is our first encounter with a concept in the Lisp/Scheme world
called "quoting".

Lets bind a value to a symbol first:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  let message = "Hello"
#+end_src

We should already understand that printing ~message~ will print the
string we assigned/bound to it:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  print message
#+end_src

However if we *quote* the ~message~ symbol we get what looks like a
string "message":

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  print 'message
#+end_src

In some sense it really is a "string" in that it is a sequence of
UTF-8 characters (with some restrictions).

We can even get the string of the symbol as a real string:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  'message as string
#+end_src

Its kind of like in English where you put quotes around a word to
signify the word itself (or in the case of "scare quotes" some other
connotation other than the typical meaning).

Just to hammer this home that it really is a string you can take the
symbol string and bind it to another symbol:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  let message-symbol-string = ('message as string)
#+end_src

Meta...

And in fact you don't even need to have assigned something to a symbol
for it to "exist":

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  print ('IHaventBeenAssignedToYet as string)
  'hello
#+end_src

This ~'~ character is called a "sugar-quote" and is used for syntax
macros. There is another kind of quote called a "spice-quote" using
the ~`~ character which works at a deeper level.

A full explanation of the implications of the sugar-quote won't be
continued until Level 3. The spice-quote will be discussed at Level 4
as it is a novel concept in Scopes.

I will leave it here that you can use the special function
~sc_parse_from_string~ to see for yourself that these special
characters are just syntax that will get expanded to concrete
functions in the language:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  sc_parse_from_string "hello"

  'hello

  sc_parse_from_string "'hello"

  ''hello

  sc_parse_from_string "''hello"

  sc_parse_from_string "`hello"

  sc_parse_from_string "'hel'lo"

#+end_src

***** Operating On Symbols

As we saw above we can cast them to strings:

#+begin_src scopes
  print ('newsymbol as string)
#+end_src

But we can also compare symbols like strings too:

#+begin_src scopes
  'newsymbol == 'newsymbol
  'newsymbol != 'othersymbol
#+end_src


**** Lists

***** Some Context

In scripting languages like Python they often provide a number of
primitive data structures like lists, tuples, and maps/dictionaries or
even sets.

These are all very high-level concepts compared to the "structs and
arrays" of low-level languages like C or C++ (without the standard
library).

Scopes aims to combine the efficiency and control of languages like
C/C++ while maintaining a relatively high-level veneer similar to
Python.

Thus the base language only provides a single seemingly-high-level
data structure called simply a list.

However, while similar in some aspects to the "list" of Python this
list is very different in implementation and behavior and actually
comes from the Scheme/Lisp heritage (LISt Processing).

Describing the full behavior of lists is a topic for Level 3 but here
we describe some ways that basic lists can be used in place of mutable
lists and maps from a language like Python.

In Level 2 we will also describe how you can get data structures that
actually behave like Python lists (i.e. linked-lists),
maps/dictionaries (i.e. hash-maps) from the standard library. Its
worth forewarning that in the vast majority of cases you will probably
want to employ these more classical data structures for performance
reasons. The lists we are discussing here are flexible in a
fundamental way but are only practically used in a specific context
that won't really be elaborated on until Level 3 when we talk about
syntax macros.

We start with defining a simple list of numbers from 0 to 5 in a few
different syntax forms:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  '(0 1 2 3 4 5)

  '(0,1,2, 3, 4 , 5)
#+end_src

Where we have the normal space delimiter, but also the comma character
which lets you elide whitespace.

The empty list can be given as:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  '()
#+end_src


Notice our friend ~sugar-quote~ (~'~) from the Symbols section. You
only need this on the outermost list when you define nested lists:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  '(0
    ("red" "blue" "green")
    ()
    10
  )
#+end_src


Note that to define sublists you do not need another ~'~ character.

***** A Quick But Necessary Tangent: Why the '?

Again this is a topic for Level 3 but I'll give you the gist here.

First try it out without the ~'~:

#+begin_example
  $0 ► (0 1)
  <string>:1:1: in fn <string>:1
      (0 1)
  <string>:1:1: while checking expression
      (0 1)
  error: cannot call value of type i32
#+end_example

You can see that scopes is trying to call the function ~0~ on the
parameter ~1~. Thats kind of weird...

In Lisp & Scheme like languages the list is not only a data-structure
for program data like numbers, strings, etc. but it is also the data
structure in which the program itself is contained in. This property
is called homoiconicity because code and data use the same (homo)
syntax (iconicity). This basically makes it much easier to write
programs that write other programs since a function can take in a
piece of language syntax, rearrange it and output something
else. These constructs are called macros and the practice in general
is called "metaprogramming".

Observe that even normal looking language syntax can also be a list if
you ~sugar-quote~ it:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  '(print "hello")
#+end_src

This is how "code is data"; although as we saw above data is not
always code.

This concept doesn't really have a good analog in most scripting
languages primarily because metaprogramming is something of a
dangerous and complex feature that requires a lot of sophistication on
the part of the programmer. And scripting languages are meant to be
simple and not too complicated for beginner to intermediate
programmers.

Don't be fooled though. Metaprogramming is an incredibly powerful
language feature that used correctly can be very useful. Scopes uses
these features extensively and so we will have to become familiar with
them. Just not now. Levels 3 and above will deal with them.

Enough metaprogramming I came here to manipulate some data!

***** List Creation & Manipulation

We have already shown a basic way to define lists manually. But you
can also do this programmatically as well. The operations are a bit
stripped down in Scheme fashion but its well known that these
operations can be the foundation for arbitrary other manipulations.

First is the cons function, which is a function taking two values, the
second of which must be a list. It then returns a new list with the
first element being the first argument and the rest of the elements
are the elements of the second (list) argument. An example helps:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  cons 0 '(0 1)
  cons '() '(0 1 2)
#+end_src

Again I won't go reeling into all the mind-expanding implications this
has here. Lets keep things grounded for now.

Normally in Lisps/Schemes they would have the additional ~car~ and
~cdr~ functions for taking lists apart. In Scopes we just have the
opposite of ~cons~; ~decons~.

#+begin_src scopes :tangle _bin/primitives_lists.sc
  decons '(0 1)
  decons '(() 0 1 2)
#+end_src

There is also a similar concatenation operator to strings:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  .. '(0 1) '(2 3)
  '(5 6) .. '(7 8)
#+end_src

Lists can also be compared for equality:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  '(0 1) == '(0 1)
  '(0) == '(1)
#+end_src

***** Some Common Listy Structures

Having only a list may seem kind of limiting; and it is in order to
maintain simplicity.

The most obvious omission is the lack of any kind of map type.

A common convention in Lisps is to encode maps in lists 2 ways:

- *plist* :: [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Property-Lists.html][Property List]]
- *alist* :: [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html][Association List]]

A plist uses an un-nested list where every two elements are
interpreted as a pair. Keys cannot be repeated (at least if you want
it to work properly):

#+begin_src scopes :tangle _bin/primitives_lists.sc
  let plist = '( 
      "bob" 10
      "suzy" 12
      "jill" 8
  )
#+end_src

This is often how keyword function arguments are implemented in
Lisp-like languages.

An alist uses a single level of nesting where key-value pairs are sub
lists of two elements:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  let alist = '( 
      ("bob" 10)
      ("suzy" 12)
      ("jill" 8)
  )
#+end_src

The more elements you have in your mapping the "better" the
datastructure you will want roughly in order of the number of
elements you have:

plist < alist < hash table

Where plists are used for very small numbers of elements (1-20). The
boundary between alists and hash tables would require some
benchmarking. If in doubt you should probably use a hash table.

I am unaware of any functions for dealing with these structures in
Scopes, but I think it helps to understand how these things are used
in practice since coming from a scripting language these kinds of
things are not used.

To add key-value pairs to a plist you could use concatenation:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  let plist = (.. '("dan" 15) plist)
#+end_src

And to add to an alist you would use cons:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  let alist = (cons '("dan" 15) alist)
#+end_src



*** TODO Arithmetic & Mathematics

We have kind of already seen arithmetic above in the section on
Operators.



**** TODO Special Mathematical Functions and Numbers

|   | symbol |
|---+--------|
|   | ~ln~   |
|   | ~pi~   |
|   | ~sin~  |
|   | ~cos~  |



*** Basic Control Flow

**** Conditionals & Boolean Expressions

Boolean expressions are expressions which evaluate to either ~true~ or
~false~.

#+begin_src scopes :tangle _bin/conditional_bool-exprs.sc
  true and true or false

  0 > 3

  "goodbye" != "hello"
#+end_src

This can be used in combination with the familiar if-else kind of
syntax:

#+begin_src scopes :tangle _bin/conditional_bool-exprs.sc

  let valid? = true

  if valid? (print "SO TRUEE!!")


  let height = 3.3

  let MIN_HEIGHT = 4

  if (height < MIN_HEIGHT)
      print "You must be " MIN_HEIGHT "ft to ride"
  else
      print "Step aboard!"


  let color-pick = "red"

  # choose a complementary color
  let complement =
      if (color-pick == "blue")
          "yellow"

      elseif (color-pick == "red")
          "green"

      elseif (color-pick == "yellow")
          "purple"

      else
          "invalid-color"

  if (complement != "invalid-color")
      print complement "is the complement to" color-pick
  else
      print "You did not pick a primary color"


#+end_src

Some values can be implicitly interpreted as booleans:

#+begin_src scopes :tangle _bin/conditional_implicit-bool.sc
  if (not none) (print "boolable")

  if (not 0) (print "boolable")
  if 1 (print "boolable")

  if inf (print "boolable")
  if nan (print "boolable")
#+end_src

As we will see in type casting these values can be explicitly cast as
bools:

#+begin_src scopes :tangle _bin/conditional_implicit-bool.sc
  0 as bool
  1 as bool
  -1 as bool
#+end_src

~string~ and ~null~ types cannot be cast to booleans.

**** Loops

The fundamental loop in scopes is very general, but maybe not exactly
what you are used to from a langauge like Python.

Scopes does provide these comfy loops though and its very satisfying.

***** For-Loop

Here is a basic for loop like you would find in python:

#+begin_src scopes :tangle _bin/loop_range-forloop.sc
  for i in (range 10)
      print i
#+end_src


You can loop over the language level lists, but they need to be
"quoted" by placing a single apostrophe ~'~ at the beginning of the
list just like in other Scheme languages. Otherwise it will try to
call the function ~0~ on arguments ~1~ and ~2~.

#+begin_src scopes :tangle _bin/loop_forloop.sc
  for i in '(0 1 2)
      print i
#+end_src

***** While-Loop

#+begin_src scopes :tangle _bin/loop_whileloop.sc
  local i = 0
  while (i < 5)
      print i
      i += 1
#+end_src

***** General Loop

The general loop has a few more requirements but is more flexible.

There should be:

1. A path to "repeat" the loop
2. A path to break out of the loop

#+begin_src scopes :tangle _bin/loop_loop-A.sc
  loop (a = 0)
      print a
      if (a < 10)
          repeat (a + 1)
      else
          break a
#+end_src


Technically the ~repeat~ is redundant and a bare value at the end of a
scope will "return" it and continue the loop.

#+begin_src scopes :tangle _bin/loop_loop-B.sc
  loop (a = 0)
      print a
      if (a < 10)
          a + 1
      else
          break a
#+end_src

You do need the break though, or it won't compile as this will always
be an infinite loop.


***** Fold-Loop





**** TODO Blocks

*** Type Casting

You can convert types using the ~as~ operator:

#+begin_src scopes :tangle _bin/typecast_as.sc
  # constant
  0 as f32

  1.2 as i32

  -1 as u32

  # not constant
  'a-symbol as string
#+end_src

Which is a *static cast* and happens at compile time (see caveats above).


TODO:

- ~imply~


*** TODO Functions


**** Recursion With Functions

Recursion is achieved using ~this-function~:

#+begin_src scopes :tangle _bin/recursion_01.sc
  fn rec-count (n)
      print n
      if (n > 5)
          return;
      this-function (n + 1)

  rec-count 0
#+end_src

*** Modules

Scopes provides a module system very much like python.

You can import installed libraries and use their methods such as:

#+begin_src scopes :tangle _bin/modules_import.sc
  import String
  let str = (String.String "hello")
#+end_src

Or you can dump the exported symbols (i.e. functions and variables)
into your current namespace with the ~using~ keyword:

#+begin_src scopes :tangle _bin/modules_using-import.sc
  using import String
  let str = (String "hello")  
#+end_src

You can also directly bind a loaded module to a symbol:

#+begin_src scopes :tangle _bin/modules_using-import.sc
  let string_mod = (import String)
  let str = (string_mod.String "hello")  
#+end_src

TODO:

You can write a module like this in a file ~hellomod.sc~:

#+begin_src scopes :tangle _bin/hellomod.sc
  fn hello (name)
      (print "Hello" name)

  do
      let hello
      locals;
#+end_src

And then import it like:

#+begin_src scopes :tangle _bin/modules_load-local-module.sc
  let mod = (import .hellomod)

  hellomod.hello "Bob"
#+end_src

*** Exceptions, Errors, & Assertions

**** Assertions

Scopes has the common assert function which you can use for quick
checks of boolean expressions:

#+begin_src scopes :tangle _bin/errors_assert.sc
  assert true

  assert (not false)

  assert (1 == 1)
#+end_src

This will raise an error:

#+begin_src scopes
  assert false
#+end_src

**** TODO Error Propagation

There is also the familiar ~raise~ and ~try~.




*** TODO

From the ~lang.md~ outline in the unpublished docs:

- [ ] functions
- [-] bindings
  - [X] let
  - [ ] bind
- [ ] blocks
- [X] conditionals
- [X] loops
- [ ] iterators
- [ ] streams
- [X] modules
- [ ] scopes
- [X] numbers
- [-] strings
  - [X] builtin
  - [ ] String
  - [ ] rawstring
- [ ] Tables
- [X] Lists
- [X] Infix
  - [X] basics
- [ ] dot notation
- [X] number formats
- [ ] splicing
- [ ] exception handling
- [ ] types
- [ ] classes
