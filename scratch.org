
#+begin_src scopes
  fn log (msg)
      (print (.. "===>" msg))

  log "hjello"
#+end_src

#+RESULTS:
: ===>hjello

** dunno

#+begin_src scopes
  ...
#+end_src

#+begin_src scopes
  print ::
#+end_src

#+RESULTS:
: $unnamed<List,Scope>$f4e7342eaedc433eb_c:SugarMacro

** Testing some fancy slicing syntax I'm making up:

#+begin_src scopes
  let arr = [[0 1 2] [3 4 5]]

  # basics
  (fslice arr 0 2)
  (fslice arr 0 :)
  (fslice arr 0-1 ...)
  (fslice arr (0 2) ...)

  let arr = ndarray
      [[0 1 2]
       [3 4 5]]

  let arr = ndarray
      0 1 2
          0 1 2
      3 4 5
          3 4 5
#+end_src

#+RESULTS:


** unpack
#+begin_src scopes
  fn trio (a b c)
      print a
      print b
      print c

  let a = '(0 1 2)

  trio (unpack a)

#+end_src

#+RESULTS:
: 0
: 1
: 2

** Pass
Instead of a python pass:

#+begin_src scopes
  fn nothing ()

  nothing;
#+end_src

#+RESULTS:

** Do block

#+begin_src scopes
  do
      print "hello"
#+end_src

#+RESULTS:
: hello


** forloop

Why doesn't this work?


#+begin_src scopes
  for i in (range 10)
      if (i == 1)
          print "continuing"
          continue;
      elseif (i > 2)
          print "breaking"
          break;

      print i
#+end_src

#+RESULTS:
: 0
: continuing
: 2
: breaking

*** vvv colors

#+begin_src scopes
  vvv bind Colors
  do
      let
          LIGHTGRAY =  '(200, 200, 200, 255)
          GRAY = '(130, 130, 130, 255)
          DARKGRAY = '(80, 80, 80, 255)
          YELLOW = '(253, 249, 0, 255)
          GOLD = '(255, 203, 0, 255)
          ORANGE = '(255, 161, 0, 255)
          PINK = '(255, 109, 194, 255)
          RED = '(230, 41, 55, 255)
          MAROON = '(190, 33, 55, 255)
          GREEN = '(0, 228, 48, 255)
          LIME = '(0, 158, 47, 255)
          DARKGREEN = '(0, 117, 44, 255)
          SKYBLUE = '(102, 191, 255, 255)
          BLUE = '(0, 121, 241, 255)
          DARKBLUE = '(0, 82, 172, 255)
          PURPLE = '(200, 122, 255, 255)
          VIOLET = '(135, 60, 190, 255)
          DARKPURPLE = '(112, 31, 126, 255)
          BEIGE  = '(211, 176, 131, 255)
          BROWN = '(127, 106, 79, 255)
          DARKBROWN = '(76, 63, 47, 255)
          WHITE = '(255, 255, 255, 255)
          BLACK = '(0, 0, 0, 255)
          BLANK = '(0, 0, 0, 0)
          MAGENTA = '(255, 0, 255, 255)
          RAYWHITE = '(245, 245, 245, 255)

#+end_src

** logging sugar

#+begin_src scopes
  sugar log (body...)
      qq
          do
              print "Start"
              unquote-splice body...
              print "End"

  run-stage;

  (log (print "work"))
#+end_src

#+RESULTS:

** Scopes

#+begin_src scopes

  let macros = ('bind-symbols (Scope) (a = "hello"))

  run-stage;

  print macros.a
#+end_src

#+RESULTS:
: hello

#+begin_src scopes
  let scope =
      'bind-symbols (Scope)
          message = "hello"
          name = "Bob"

  run-stage;

  print (typeof scope)
  print scope.name
  ;
#+end_src

#+RESULTS:
: Scope
: Bob



#+begin_src scopes
  let sc =
      do
          let
              x = 1
              y = "Hello"
          locals;

  print sc.x
  print sc.y
#+end_src

#+RESULTS:
: 1
: Hello

** report

#+begin_src scopes
  let a = 3

  report a

  print a
#+end_src

#+RESULTS:
: /tmp/babel-EFGjGa/prefix7aQGWT.sc:3:1: 3
: 3

** defer
#+begin_src scopes
  defer print "end of module"
  let a = (1 + 3)

  print a
#+end_src

#+RESULTS:
: 4
: end of module

** static-typify

#+begin_src scopes
  fn a ()
      none

  let t = (static-typify a)

  print t
  print (typeof t)
#+end_src

#+RESULTS:
: (%1: fn a () : (opaque@ (Nothing <-: ())) (return none)):(opaque@ (Nothing <-: ()))
: (opaque@ (Nothing <-: ()))

** llvm debug GDB

#+begin_src scopes
  let llvm.debugtrap = (extern 'llvm.debugtrap (function void))
#+end_src

#+RESULTS:


** array of structs

#+begin_src scopes
  using import struct
  using import String
  using import Array

  struct Dog
      name : String
      bark : String = "woof"
      height : f32

  local dog-arr = ((array Dog 2))

  print ((dog-arr @ 0) . bark)
  # print dog-arr

  ;
#+end_src


** Array

#+begin_src scopes

  using import Array

  let a = ((Array i32) 1 2)

  print (countof a)
#+end_src

#+RESULTS:
: 2:usize

#+begin_src scopes
  let a = (arrayof i32 0 1)

  print (typeof a)
#+end_src

#+RESULTS:
: (array i32 2)

** void return type

#+begin_src scopes
  fn dovoid ()

  print (typeof (dovoid))
#+end_src

#+RESULTS:


#+begin_src scopes


  fn dothing ()
      1 + 1

  print (typeof dothing)
#+end_src

#+RESULTS:
: Closure

** expand C macros

#+begin_src scopes
  vvv bind C:ctype
  include
      """"#include <ctype.h>
          typeof(iscntrl('a')) patched_iscntrl(char c) {
              return iscntrl(c);
          }


  using import UTF-8

  print (C:ctype.extern.patched_iscntrl (char32 "a"))
#+end_src

#+RESULTS:
: 0


** itertools pipeline, UTF en/decode

#+begin_src scopes
  using import itertools
  let utf = (import UTF-8)

  fn utf8-encode (arr)
      ->>
          arr
          utf.encoder
          string.collector ((countof arr) * (sizeof i32))

  local src = (arrayof i32 63:i32 97:i32)

  let dst = (utf8-encode src)

  print dst
#+end_src

#+RESULTS:
: ?a


encode a single character:

#+begin_src scopes
  using import itertools
  let utf = (import UTF-8)

  fn utf8-char-encode (ch)
      local arr = (arrayof i32 ch)
      ->>
          arr
          utf.encoder
          string.collector (sizeof i32)

  local src = (arrayof i32 63:i32 97:i32)

  let src = (63:i8 as i32)

  let dst = (utf8-char-encode src)

  print dst
#+end_src

#+RESULTS:
: ?

** exceptions

#+begin_src scopes
  using import struct

  struct myException
      what : string

  try
      raise (myException "an error occurred")
  except (e)
      print e.what
#+end_src

#+RESULTS:
: an error occurred

** Option

#+begin_src scopes
  using import Option
  using import struct

  struct Thing global
      always : i32
      sometimes : (Option i32)

  let t1 =
      Thing
          1
          2

  let t2 =
      Thing
          1
          none

  print t1.sometimes
  print t2.sometimes

  ;
#+end_src

#+RESULTS:
: Some
: None


#+begin_src scopes
  using import Option

  global option : (Option i32)

  option = 2

#+end_src

#+RESULTS:


** copy

#+begin_src scopes
  using import String

  local a = (String "hello")

  print a

  local b = (copy a)

  print b

  b = (String "testing")

  print b
  print a
#+end_src

#+RESULTS:
: hello
: hello
: testing
: hello

** hiden inline

The "hidden" named inline which doesn't have a lifetime scope

#+begin_src scopes
  inline hidden ()
      defer print "inline destructor"
      print "body of inline"

  print "Calling inline"
  hidden;
  print "After inline"
#+end_src

#+RESULTS:
: Calling inline
: body of inline
: After inline
: inline destructor


** exit

#+begin_src scopes
  exit
  ;
#+end_src

#+RESULTS:


** enum

#+begin_src scopes
  using import enum

  enum Actions plain
      Nothing = 0
      Terminate = 1

  print (tostring Actions.Nothing)

  let action = Actions.Nothing

  switch action
  case Actions.Nothing
      print "doing nothing"

  case Actions.Terminate
      print "Terminating"

  default
      print "default"
#+end_src

#+RESULTS:
: Nothing
: doing nothing


#+begin_src scopes
  using import enum

  enum Actions plain
      Nothing = 0
      Terminate = 1

  print (typeof Actions.Nothing)
#+end_src

#+RESULTS:
: Actions



** Indexing for-loop

The range is not constant so you can't do something like this:

#+begin_src scopes
  let things = (tupleof "a" "b" "c")

  for i in (range (countof things))
      print (things @ i)
#+end_src

#+RESULTS:

You also can't do this:

#+begin_src scopes
  let things = (tupleof "a" "b" "c")

  for thing in things
      print thing

#+end_src

#+RESULTS:

But you can do:

#+begin_src scopes
  using import itertools
  using import Array

  let things = ((Array string) "a" "b" "c")

  for idx thing in (zip (range (countof things)) things)
      print (tostring idx) thing
#+end_src

#+RESULTS:
: 0 a
: 1 b
: 2 c


