
#+begin_src scopes
  ...
#+end_src

#+begin_src scopes
  print ::
#+end_src

#+RESULTS:
: $unnamed<List,Scope>$f4e7342eaedc433eb_c:SugarMacro

Testing some fancy slicing syntax I'm making up:

#+begin_src scopes
  let arr = [[0 1 2] [3 4 5]]

  # basics
  (fslice arr 0 2)
  (fslice arr 0 :)
  (fslice arr 0-1 ...)
  (fslice arr (0 2) ...)

  let arr = ndarray
      [[0 1 2]
       [3 4 5]]

  let arr = ndarray
      0 1 2
          0 1 2
      3 4 5
          3 4 5
#+end_src

#+RESULTS:

#+begin_src scopes
  fn trio (a b c)
      print a
      print b
      print c

  let a = '(0 1 2)

  trio (unpack a)

#+end_src

#+RESULTS:
: 0
: 1
: 2


Instead of a python pass:

#+begin_src scopes
  fn nothing ()

  nothing;
#+end_src

#+RESULTS:

#+begin_src scopes
  do
      print "hello"
#+end_src

#+RESULTS:
: hello


Why doesn't this work?


#+begin_src scopes
  for i in (range 10)
      if (i == 1)
          print "continuing"
          continue;
      elseif (i > 2)
          print "breaking"
          break;

      print i
#+end_src

#+RESULTS:
: 0
: continuing
: 2
: breaking


#+begin_src scopes
  vvv bind Colors
  do
      let
          LIGHTGRAY =  '(200, 200, 200, 255)
          GRAY = '(130, 130, 130, 255)
          DARKGRAY = '(80, 80, 80, 255)
          YELLOW = '(253, 249, 0, 255)
          GOLD = '(255, 203, 0, 255)
          ORANGE = '(255, 161, 0, 255)
          PINK = '(255, 109, 194, 255)
          RED = '(230, 41, 55, 255)
          MAROON = '(190, 33, 55, 255)
          GREEN = '(0, 228, 48, 255)
          LIME = '(0, 158, 47, 255)
          DARKGREEN = '(0, 117, 44, 255)
          SKYBLUE = '(102, 191, 255, 255)
          BLUE = '(0, 121, 241, 255)
          DARKBLUE = '(0, 82, 172, 255)
          PURPLE = '(200, 122, 255, 255)
          VIOLET = '(135, 60, 190, 255)
          DARKPURPLE = '(112, 31, 126, 255)
          BEIGE  = '(211, 176, 131, 255)
          BROWN = '(127, 106, 79, 255)
          DARKBROWN = '(76, 63, 47, 255)
          WHITE = '(255, 255, 255, 255)
          BLACK = '(0, 0, 0, 255)
          BLANK = '(0, 0, 0, 0)
          MAGENTA = '(255, 0, 255, 255)
          RAYWHITE = '(245, 245, 245, 255)

#+end_src


#+begin_src scopes
  sugar log (body...)
      qq
          do
              print "Start"
              unquote-splice body...
              print "End"

  run-stage;

  (log (print "work"))
#+end_src

#+RESULTS:


#+begin_src scopes

  let macros = ('bind-symbols (Scope) (a = "hello"))

  run-stage;

  print macros.a
#+end_src

#+RESULTS:
: hello


#+begin_src scopes
  let a = 3

  report a

  print a
#+end_src

#+RESULTS:
: /tmp/babel-EFGjGa/prefix7aQGWT.sc:3:1: 3
: 3


#+begin_src scopes
  defer print "end of module"
  let a = (1 + 3)

  print a
#+end_src

#+RESULTS:
: 4
: end of module


#+begin_src scopes
  fn a ()
      none

  let t = (static-typify a)

  print t
  print (typeof t)
#+end_src

#+RESULTS:
: (%1: fn a () : (opaque@ (Nothing <-: ())) (return none)):(opaque@ (Nothing <-: ()))
: (opaque@ (Nothing <-: ()))


#+begin_src scopes
  let llvm.debugtrap = (extern 'llvm.debugtrap (function void))
#+end_src

#+RESULTS:


#+begin_src scopes
  using import struct
  using import String
  using import Array

  struct Dog
      name : String
      bark : String = "woof"
      height : f32

  local dog-arr = ((array Dog 2))

  print ((dog-arr @ 0) . bark)
  # print dog-arr

  ;
#+end_src


#+begin_src scopes
  fn dovoid ()

  print (typeof (dovoid))
#+end_src

#+RESULTS:


#+begin_src scopes


  fn dothing ()
      1 + 1

  print (typeof dothing)
#+end_src

#+RESULTS:
: Closure


#+begin_src scopes
  vvv bind C:ctype
  include
      """"#include <ctype.h>
          typeof(iscntrl('a')) patched_iscntrl(char c) {
              return iscntrl(c);
          }


  using import UTF-8

  print (C:ctype.extern.patched_iscntrl (char32 "a"))
#+end_src

#+RESULTS:
: 0


#+begin_src scopes
  using import itertools
  let utf = (import UTF-8)

  fn utf8-encode (arr)
      ->>
          arr
          utf.encoder
          string.collector ((countof arr) * (sizeof i32))

  local src = (arrayof i32 63:i32 97:i32)

  let dst = (utf8-encode src)

  print dst
#+end_src

#+RESULTS:
: ?a


encode a single character:

#+begin_src scopes
  using import itertools
  let utf = (import UTF-8)

  fn utf8-char-encode (ch)
      local arr = (arrayof i32 ch)
      ->>
          arr
          utf.encoder
          string.collector (sizeof i32)

  local src = (arrayof i32 63:i32 97:i32)

  let src = (63:i8 as i32)

  let dst = (utf8-char-encode src)

  print dst
#+end_src

#+RESULTS:
: ?


#+begin_src scopes
  using import struct

  struct myException
      what : string

  try
      raise (myException "an error occurred")
  except (e)
      print e.what
#+end_src

#+RESULTS:
: an error occurred




#+begin_src scopes
  using import Option
  using import struct

  struct Thing global
      always : i32
      sometimes : (Option i32)

  let t1 =
      Thing
          1
          2

  let t2 =
      Thing
          1
          none

  print t1.sometimes
  print t2.sometimes

  ;
#+end_src

#+RESULTS:
: Some
: None


#+begin_src scopes
  using import Option

  global option : (Option i32)

  option = 2

#+end_src

#+RESULTS:



#+begin_src scopes
  using import String

  local a = (String "hello")

  print a

  local b = (copy a)

  print b

  b = (String "testing")

  print b
  print a
#+end_src

#+RESULTS:
: hello
: hello
: testing
: hello


#+begin_src scopes
  inline hidden ()
      defer print "inline destructor"
      print "body of inline"

  print "Calling inline"
  hidden;
  print "After inline"
#+end_src

#+RESULTS:
: Calling inline
: body of inline
: After inline
: inline destructor
