* Level 2: Things you would know if you knew C/C++


** Big Concepts

Scopes can be said to to have the following features/properties which
will be discussed throughout this section and assumed to have
knowledge of.

These are that Scopes:

1. supports the C ABI directly.
2. is statically typed,
3. is low level and concerned with memory layout and management directly,
4. supports *multi-stage programming* where the compiler can stay
   online during exectution,
5. supports many zero-cost abstractions when possible, and
6. has a borrow checker.

We will discuss everything but the borrow checker in detail in this
section. Borrow checking and lifetime management is a somewhat more
advanced feature than is available in C/C++; made popular by the Rust
programming language. It is unavoidable that we must confront it when
using C/C++ equivalent functionality in this level, however we avoid
discussion of direct manipulation of its features or constructs meant
to directly leverage it.

Instead we will describe the general behavior and the minimum amount
of annotations and code needed to "make it happy" and avoid
errors. This is good because ultimately it helps us make less errors
and the overhead on the code is rather minimal when compared to
writing C/C++ code.

*** Compilation & Code Generation

**** The Scopes Compilation Model

The following table summarizes the stages of compilation and execution
of Scopes code:

| Order | Stage       | From                          | To                 | Macro System |
|-------+-------------+-------------------------------+--------------------+--------------|
|     1 | Parsing     | Data Interchange Format (SLN) | S-Expression Tree  |              |
|     2 | Expansion   | S-Expression Tree             | Untyped Scopes AST | Sugar        |
|     3 | Checking    | Untyped Scopes AST            | Typed Scopes IL    | Spice        |
|     4 | Translation | Typed Scopes IL               | LLVM IR / SPIR-V   |              |
|     5 | Execution   | LLVM IR / SPIR-V              | Program Output     |              |

This table will be very important to understand later concepts in
metaprogramming and the two macro systems (sugars and spices of which
we briefly met in Level 1).

However for now its enough to look at stages 3 through 5.

In a scripting language like python you would probably only have steps
1 and 5, and perhaps 4 depending on the runtime.

In a language with metaprogramming (i.e. macros) you add in step 2
which allows for generating new code. C/C++ both have this with
different sophistication levels.

For a statically typed language you add in step 3 which is to do type
checking.

Step 4 is common to both Scopes and C/C++ however it is different in
that this is controlled directly in the code rather than through a
compiler and/or build system which is controlled though either a
command line interface (unix), GUI (MSVSC), or separate language (most
build systems like Make, CMake, ninja, etc.)

This opens up a wide number of possibilities that you can do in your
actual code and removes most of the need for interacting with a build
system -- which are notoriously aggravating to use.

This does come at the tradeoff that the actual executable code is much
larger because it must carry around the compiler it uses to generate
that code at run time. In the case of Scopes this (currently) is the
LLVM toolset which while sophisticated and generates high quality
code, is quite heavy weight.

This requirement is perhaps one of the major considerations to make
when deciding whether scopes is the right tool for the job. In the
creator's (Leonard Ritter's) own words Scopes is suitable for
"monolithic multimedia applications". This includes things like video
games but is perhaps also applicable to native GUI applications,
window managers, desktop environments, audio or video editing programs
etc.

These kinds of applications are normally very large anyway due purely
to the kinds of assets that are needed to ship with them and the
overhead of a compiler is likely to be negligible.

Also considering the bloat of many GUI frameworks, like Electron,
having a compiler come for the ride is a drop in the bucket and more
than pulls its weight for the price.

All that said AOT compilation is possible with Scopes, so you can have
your cake and eat it too. However, this not being the primary use-case
for Scopes applications you will have to work a little extra hard to
achieve it. I consider this an advanced topic and will be covered in
Level 5.


**** COMMENT Code Generation


*** COMMENT Static Types

That Scopes is statically typed (like C/C++) is one of the biggest
differences between a "dynamically typed" scripting language like
Python.

In Level 1 we were mostly able to ignore having to declare types at
all. This is because Scopes is able to infer types. Being able to
infer types is not a unique feature of Scopes and other languages,
particularly those from the functional languages like OCaml, have type
inference.

However, the mainstream statically typed languages like C/C++ or Rust
all do not do type inference, meaning you must -- almost -- always
declare your types; even if the compiler could have done it for you.

While these seems annoying there is a utility in this in that
everything is annotated explicitly so you don't get confused when
something gets inferred to a type you didn't intend to.

In Scopes you can choose to let the compiler infer types for you (when
it can) or explicitly declare them.

Because the syntax is often optimized for automatic type inference the
explicit type declarations typically are available as optional extra
syntax.


TODO:
- type constructors (typedef)
- constructing values from types
- type declaration syntax (annotate examples from Level 1)
- 



TODO:

#+begin_src scopes
  print (typeof 'print)
  print (storageof Symbol)
  print (storagecast 'print)
#+end_src

#+RESULTS:
: Symbol
: u64
: 4809770749102710031:u64

**** TODO COMMENT Typification

~static-typify~

*** COMMENT Low Level Memory Management & Layout

**** Pointers

**** Heap Memory Allocation

**** Constructors & Destructors

**** defer and other lifetime management

*** COMMENT Constants

*Constant* values are opposed to *dynamic* values in that constant
values can be known before compilation to machine code.

The compile-time vs run-time distinction in Scopes is considerably
different than in most purely AOT compiled languages like C/C++ and is
a major feature of the language.

** Arrays

*** C-style Arrays

First we must talk about the C-style arrays.

#+begin_src scopes
  let arr = ((array f32 2) 0 1)
  print arr
#+end_src

#+RESULTS:
: (arrayof f32 0.0 1.0)


#+begin_src scopes
  let arr = (arrayof f32 0 1 2 3)

  print arr
#+end_src

#+RESULTS:
: (arrayof f32 0.0 1.0 2.0 3.0)


#+begin_src scopes
  let arr = (arrayof f32 0 1 2 3)

  print (arr @ 1)
#+end_src

#+RESULTS:
: 1.0

Array of structs

#+begin_src scopes
  using import struct

  struct Dog
      name : string
      bark : string = "woof"
      height : f32

  let d0 =
      Dog
          "Fido"
          "Bow! Wow!"
          43

  let d1 =
      Dog
          "Max"
          "Wong! Wong!"
          56

  # array type can't be accessed with dynamically generated indices
  # (like from the for loop below) because you could easily go beyond
  # the bounds of the array
  local dogs = (arrayof Dog d0 d1)

  for idx in (range 2)
      # access the struct members of the array elements
      print ((dogs @ idx) . name) "says" ((dogs @ idx) . bark)

  for idx in (range 2)
      # access the struct members of the array elements
      ((dogs @ idx) . name) = "George"

      print ((dogs @ idx) . name)


  local dog-arr = (array Dog 2)
  for i in (range 2)
      (dog-arr @ i) =
          Dog
              "Max"
              "Wong! Wong!"
              56

#+end_src

#+RESULTS:

*** Arrays

#+begin_src scopes
  using import Array

  # Fixed size array
  local arr = ((Array i32 10))
  print (typeof arr)

  # Growing array (e.g. C++ vector)
  local arr = ((Array i32))
  print (typeof arr)

  # You can explicitly use GrowingArray or FixedArray types
  local garr = ((GrowingArray i32))
  local farr = ((FixedArray i32 10))

  # add a value to the array
  let element = ('append arr 0)

  print element

  print (countof arr)
  print (arr @ 0)

  # assign to a particular location
  arr @ 0 = 2
  print (arr @ 0)

  # TODO
  # insert values in between
  # 'append arr 4
  # 'insert arr 1 3

  print "last:" ('last arr)
  print "pop:" ('pop arr)

  # WARNING: segfault, no last element
  # print "last:" ('last arr)

  # remove
  'append arr 0
  'append arr 1

  'remove arr 0

  print arr

  # you can swap values
  print "Before Swap"

  'append arr 0
  print (arr @ 0)
  print (arr @ 1)

  print "After Swap"
  'swap arr 0 1

  print (arr @ 0)
  print (arr @ 1)

  # # reverse
  # print "reverse"

  # arr = ('reverse arr)
  # print (arr @ 0)
  # print (arr @ 1)

  # # sort
  # print "sort"
  # 'sort arr
  # print (arr @ 0)
  # print (arr @ 1)


  # remove all values in the array
  'clear arr
  print (countof arr)

  # WARNING: segfault if you try to access values that aren't there
  #
  # arr @ 0

  # get the capacity of the array, when this is exceeded it will be
  # expanded
  print "capacity:" ('capacity arr)

  # add capacity + 1 elements
  for i in (range 5)
      'append arr i

  # capacity is expanded
  print "capacity:" ('capacity arr)

  # again
  for i in (range 6)
      'append arr (i + 5)
  print "capacity:" ('capacity arr)

  # etc.

  # fixed arrays have the capacity you give them
  local arr = ((Array i32 10))

  print "capacity:" ('capacity arr)


  # You can use 'resize' or 'reserve' to force a particular capacity

  # resize will initialize the elements
  print "resize"

  local arr = ((Array i32))

  print "capacity:" ('capacity arr)
  print "countof:" (countof arr)
  'resize arr 10
  print "capacity:" ('capacity arr)
  print "countof:" (countof arr)

  print (arr @ 0)

  # reserve will not initialize the elements

  print "reserve"
  local arr = ((Array i32))

  print "capacity:" ('capacity arr)
  print "countof:" (countof arr)
  'reserve arr 10
  print "capacity:" ('capacity arr)
  print "countof:" (countof arr)

  # WARNING: segfault, not initialized
  # print (arr @ 0)


  # casting to generators
#+end_src

#+RESULTS:


You can also construct arrays with initial values:

#+begin_src scopes
  using import Array

  let things = ((Array string) "a" "b" "c")

  let numbers =
      (Array f32)
          4.0
          3.0

  print (numbers @ 0)

  using import struct

  struct Dog plain
      name : string
      bark : string = "woof"
      height : f32

  let dogs =
      (Array Dog)
          Dog
              "Fido"
              "Bow! Wow!"
              43
          Dog
              "Max"
              "Wong! Wong!"
              56


  print ((dogs @ 0) . name)
#+end_src

#+RESULTS:
: 4.0
: Fido


*** Some Examples

**** Looping Over Arrays

Arrays can be cast to generators implicitly so we can loop over them
directly:

#+begin_src scopes
  using import Array

  let things = ((Array string) "a" "b" "c")

  for thing in things
      print thing
#+end_src

#+RESULTS:
: a
: b
: c

A common pattern in programming languages is to loop over a range of
values with an index.

In "C-style" you would use a for-loop with an increment counter and
then access the data from the array you want to iterate over.

In Scopes you can do this if you know everything statically/constant:

#+begin_src scopes
  using import Array

  let array_size = 3

  let things = ((Array string array_size) "a" "b" "c")

  # print (things @ 0)

  loop (idx = 0)

      if (idx < array_size)

          print (.. (tostring idx) ": " (things @ idx))

          repeat (idx + 1)
      else
          break idx

  ;
#+end_src

#+RESULTS:
: 0: a
: 1: b
: 2: c


If you don't know the length of the array you can do something like
this:

#+begin_src scopes
  using import Array

  local things = ((Array string) "a" "b" "c")

  for idx in (range (countof things))
      print (.. (tostring idx) ": " (things @ idx))
#+end_src

#+RESULTS:
: 0: a
: 1: b
: 2: c

However, here you have a potential to go out-of-bounds with the loop
because the ~range~ is not constant and computed at run time. I.e. if
it was ~(range 4)~ you would get a segfault.

Notice also that to make this work we needed to make the ~things~ a
mutable variable with ~local~.

So this isn't really a recommended way to do things.

Similar to how you would do this in Python you can use the ~zip~
generator from ~itertools~:

#+begin_src scopes
  using import itertools
  using import Array

  let things = ((Array string) "a" "b" "c")

  for idx thing in (zip (range (countof things)) things)
      print (.. (tostring idx) ": " thing)

#+end_src

#+RESULTS:
: 0: a
: 1: b
: 2: c

** Strings

There are two common types of strings in Scopes which is necessary for
C compatibility. This might be simplified in the future but
nonetheless its useful to understand the difference between them.

*** Scopes Strings

The vanilla string in Scopes is the type ~string~. This is what you
get from the primitive form.

#+begin_src scopes
  let digits = "0123456789"

  print (typeof digits)
#+end_src

#+RESULTS:
: string

You can retrieve elements (characters) from this string.

Where the value is the int value for the char (~i8~) it encodes.

#+begin_src scopes
  let digits = "0123456789"

  print (typeof (digits @ 1))
  print (digits @ 1)

#+end_src

#+RESULTS:
: i8
: 49:i8


The other kind of string is similar to the ~Array~ type previously
discussed. It is allocated on the heap and can grow in size.

It is provided in the standard library module ~String~:

#+begin_src scopes
  using import String

  let str = (String "Hello")
  let str = ("Hello" as String)

  print (typeof str)
#+end_src

#+RESULTS:
: <GrowingString i8>

You will notice that the type of ~String~ is only ~<GrowingString i8>~. 

In the future their may be support for similar constructs like
~FixedString~ and parametric types.

It has similar methods as ~Array~:

#+begin_src scopes
  using import String

  local str = (String "Hello")

  print ('capacity str)
  'append str " there sir"
  print ('capacity str)

  print str

#+end_src

#+RESULTS:
: 10:usize
: 27:usize
: Hello there sir

*** C-like Strings

These are null-terminated strings that are compatible with C-strings.

They can be constructed using the ~rawstring~ type.

#+begin_src scopes
  let cstring = ("hello" as rawstring)

  print (typeof cstring)
#+end_src

#+RESULTS:
: (@ i8)

In keeping with how strings are implemented in C, this is really just
a pointer to an array of characters (~i8~) as we can see from the
above type.



*** Putting Them Together

This is perhaps the biggest "wart" in Scopes that most users will
encounter and it is there for a good reason: compatibility with C.

Hating on C strings is a very common thing to do, but because
maintaining a 1:1 correspondance with C is a very high priority it
must be dealt with. Thankfully Scopes provides some great tools for
working with this complication.

Also, you may not actually have to deal with ~rawstring~ very often in
your code. Only in the places where you interface with C code will it
be a problem.

In practice you can cast `rawstring` to the appropriate Scopes type
and move on.

Here are some other notes on converting between the string types.

When declaring a string literal, because it is constant, a cast via
~as~ is zero-cost and the ~string~ type for the literal is never
instantiated.

E.g.:

#+begin_src scopes
  "hello" as rawstring

  using import String
  "hello" as String
#+end_src

You can also convert a ~String~ to a ~rawstring~ easily:

#+begin_src scopes
  using import String

  ("hello" as String) as rawstring
#+end_src

#+RESULTS:

However to convert a rawstring to a String you will need to construct
it directly.

#+begin_src scopes
  using import String

  let rstr = ("hello" as rawstring)

  let str = (String rstr 5)

  # or get the length dynamically using the string C lib
  import C.string
  let str = (String rstr (C.string.strlen rstr))

#+end_src

#+RESULTS:

The last thing you might want to convert to a string fairly often (and
especially when interacting with the C standard library) is an array
of char to a string.

This can be done as follows:

#+begin_src scopes
  using import String

  # Must be local because we need a pointer to it
  local arr = (arrayof i8 0 1 2 3)

  # pass a pointer to the array and the length of the array
  let str = (String (& arr) (countof arr))
#+end_src


*** Encodings & Conversion

In addition to converting between the string types you will also at
some point need to deal with encodings and converting between arrays
of bytes/ints and strings.

For this there is the ~UTF-8~ module in the standard library for which
we already saw the use of the ~char32~ function.

The encoding (ints to string) and decoding (string to ints) functions
are currently only implemented as generators; which while very useful
are a little cumbersome to use if you aren't familiar with generators
and collectors yet.

So we suggest simply making a wrapper function that will do the
conversion for you without generators:

#+begin_src scopes
  using import itertools
  let utf = (import UTF-8)

  fn utf8-encode (arr)
      ->>
          arr
          utf.encoder
          string.collector ((countof arr) * (sizeof i32))

  local decoded-string = (arrayof i32 63:i32 97:i32)
  print (utf8-encode decoded-string)

  # single charactar encode
  fn char-encode (ch)
      local arr = (arrayof i32 ch)
      (utf8-encode arr)

  print (char-encode 63:i32)
#+end_src

#+RESULTS:
: ?a
: ?


TODO make the decoder since there is no default collector for arrays.

** I/O

Currently low level I/O is handled using the C standard libraries (or
whatever other library you want).

Some tips though for interfacing with them.

#+begin_src scopes
  using import String
  import C.stdio

  let input-prompt = ">"
  let result-prompt = "==>"

  # display a prompt
  (C.stdio.fputs "> " C.stdio.stdout)

  # allocate a C-array for collecting input
  local input = ((array i8 2048))

  # get input from stdin
  (C.stdio.fgets input 2048 C.stdio.stdin)

  # then convert to a string
  let input-str = (String (& input) (countof input))

  print (result-prompt input-str)
#+end_src


** structs

Structs are a similar construction as in C/C++, however they are
different in that they aren't a concept built into the core language
and instead are provided in the standard library.

Here is an example of defining a struct type:

#+begin_src scopes
  using import struct

  struct Example
      value : i32
      choice = false
      text : string = ""

#+end_src

First we import the symbols in the struct module (i.e. ~struct~) and
then we define the fields.

Fields can be declared in 3 ways:

1. with a type only (which must be provided upon construction)
2. with only a default value which the type will be inferred
3. both a type and a default value, which must match

In the syntax used above there will be a new symbol defined as
~Example~.

#+begin_src scopes
  using import struct

  let Example =
      struct
          value : i32
          choice = false
          text : string = ""

#+end_src

#+RESULTS:

#+begin_src scopes

  # 1. C-ish looking declaration
  local example : Example
      value = 100
      text = "test"

  # 2. Assignment "scopes-style"
  local example =
      Example
          value = 100
          text = "test"

  print example.value
  print example.text

#+end_src


Just to emphasize that we are still in Scopes and that you can still
use all the parens you want to make them:

#+begin_src scopes
  using import struct

  struct thing
      what : string

  let t = (thing (what = "test"))

  print t.what
#+end_src

#+RESULTS:
: test

#+begin_src scopes
  using import struct

  struct thing
      what : string
      size : u32

  let t =
      thing
          "Other thing"
          1:u32

  print t.what
  print t.size

  let d =
      thing
          size = 1:u32
          what = "Other thing"

  print d.what
  print d.size
#+end_src

#+RESULTS:
: Other thing
: 1:u32
: Other thing
: 1:u32

** Scopes (not the language)


** Type Definitions

#+begin_src scopes
  let int : i32 = 0:i32
  print int
#+end_src

#+RESULTS:
: 0

You must use the explicitly typed literal.

** Const

#+begin_src scopes
  print (constant? 1)
  local a = 1
  print (constant? a)
#+end_src

#+RESULTS:
: true
: false

** Type Annotations


*** Variables

Similar to C/C++ you can declare variables without explicitly setting
their values and give them a type.

#+begin_src scopes
  local count : i32

  print count
  count = 4
  print count
#+end_src

#+RESULTS:
: 0
: 4

*** Functions

The return values of functions can be explicitly typed, and will be
type-checked:

#+begin_src scopes :tangle _bin/functions_returns.sc
  fn get-origin ()
      returning (_: i32 i32)

      _ 0 0

  let a b  = (get-origin)

#+end_src

#+RESULTS:

The ~returning~ statement can occur anywhere in the function
block. Types will not be cast and the annotation will be strictly
checked.


** dump

#+begin_src scopes
  fn add (a b)
      dump a b
      a + b

  add 3 4
#+end_src

#+RESULTS:


** TODO COMMENT Operator Overload

** Type Methods

Types can have methods associated with them similar to how classes do.

#+begin_src scopes

#+end_src


** Metamethods

Similar to Python types support the idea of metamethods (called magic
methods in Python) which are special methods that when implemented can
be used in a protocol for various kinds of tasks.

Metamethods are methods that start with a double underscore. The
metamethod symbol must match the corresponding operators.



** Dynamic Dispatch

#+begin_src scopes
  using import enum
  enum State
      a : StateA
      b : StateB

  local curState : State = (State.a (StateA))
  # now when you deal with states, you do this:
  dispatch curState
  case a ()
      'init a
  case b ()
      'init b
  default
      ;

  # there's a shorthand for doing the same thing with all fields of an enum:
  'apply curState
      inline (T self)
          'init self
#+end_src

** Tuples

In Level 1 we saw how to dynamically define tuples with ~tupleof~. You
can also declare the type in full first before instantiating.

#+begin_src scopes

  print
      ((tuple i32 f32) 0:i32 1:f32)
#+end_src

#+RESULTS:
: (tupleof 0 1.0)

#+begin_src scopes
  let tup-type = (tuple (a = i32) (b = u64))

  print (tup-type (a = 0) (b = 1:u64))
#+end_src

#+RESULTS:
: (tupleof 0 1:u64)

** Including C Functions

If you have a newer version of Scopes the following modules are
included the standard library already since they are commonly used:

#+begin_src scopes :tangle _bin/externc2.sc
  import C.stdio
  import C.string
  import C.stdlib
  import C.socket
#+end_src

For the other libraries you will need to manually include them. This
is a fairly common thing to do in Scopes for interfacing with external
libraries. The C standard library functions are easy to work with in
the tutorial since they are available on all systems, but the method
generalizes and we will see how to do this later.


To load the header for a non-builtin C standard library you will need
to use the ~include~ function which returns a Scope.

#+begin_src scopes
  let stdio = (include "stdio.h")
#+end_src

#+RESULTS:

Then you will need to access the actual symbols from this Scope.

The following sub-scopes are available for the different kinds of
symbols in a C file:

- enum
- union
- extern
- typedef
- const
- define
- struct

#+begin_src scopes
  let stdio = (include "stdio.h")
  for k v in stdio (print k)
#+end_src

#+RESULTS:
: struct
: union
: enum
: define
: const
: typedef
: extern

A common pattern is to dump these all into the same scope for easier
access:

TODO: for now it just prints all of them.

#+begin_src scopes
  fn print_header_symbols (header-scope)
      # TODO: convert to a merge algorithm

      for symbol-key symbol-scope in header-scope

          # we must "unbox" the Scope since 'header' is a Scope and values
          # are "boxed" meaning they can have any type. To unbox is to tell
          # the compiler "hey this is of this type" since we know this is true
          let symbol-scope = (symbol-scope as Scope)

          loop (sub-key sub-value idx = ('next symbol-scope -1))
              if (idx == -1)
                  break;

              print symbol-key ":" sub-key ":" sub-value
              # 'bind merge-scope sub-key sub-value

              'next symbol-scope idx


  let header = (print_header_symbols (include "stdio.h"))

#+end_src

#+RESULTS:
#+begin_example
struct : _G_fpos_t : <struct _G_fpos_t>
struct : _G_fpos64_t : <struct _G_fpos64_t>
struct : _IO_FILE : <struct _IO_FILE>
struct : _IO_marker : <struct _IO_marker>
struct : _IO_codecvt : <struct _IO_codecvt>
struct : _IO_wide_data : <struct _IO_wide_data>
struct : __va_list_tag : <struct __va_list_tag>
define : __UINT_FAST16_FMTu__ : "hu"
define : __UINT_FAST16_FMTo__ : "ho"
define : __UINT_FAST16_MAX__ : 65535
define : __INT_FAST16_FMTi__ : "hi"
define : __INT_FAST16_FMTd__ : "hd"
define : __INT_FAST16_MAX__ : 32767
define : __UINT_FAST32_MAX__ : 4294967295:u32
define : __INT_FAST32_FMTi__ : "i"
define : __INT_FAST32_FMTd__ : "d"
define : __INT_FAST32_MAX__ : 2147483647
define : __UINT_FAST16_FMTX__ : "hX"
define : __UINT_FAST16_FMTx__ : "hx"
define : __INT_FAST64_FMTi__ : "li"
define : __GLIBC_USE_IEC_60559_FUNCS_EXT : 0
define : __INT_FAST64_FMTd__ : "ld"
define : __INT_FAST64_MAX__ : -1
define : __UINT_FAST32_FMTX__ : "X"
define : __UINT_FAST32_FMTx__ : "x"
define : __GLIBC_USE_IEC_60559_TYPES_EXT : 0
define : __UINT_FAST32_FMTu__ : "u"
define : __UINT_FAST32_FMTo__ : "o"
define : __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X : 0
define : __FINITE_MATH_ONLY__ : 0
define : __GLIBC_USE_LIB_EXT2 : 0
define : __UINT_FAST64_FMTX__ : "lX"
define : __UINT_FAST64_FMTx__ : "lx"
define : __UINT_FAST64_FMTu__ : "lu"
define : __GLIBC_USE_IEC_60559_BFP_EXT_C2X : 0
define : __UINT_FAST64_FMTo__ : "lo"
define : __UINT_FAST64_MAX__ : 4294967295:u32
define : __GLIBC_USE_IEC_60559_BFP_EXT : 0
define : __INTPTR_FMTd__ : "ld"
define : __INTPTR_FMTi__ : "li"
define : __PTRDIFF_WIDTH__ : 64
define : __PTRDIFF_FMTd__ : "ld"
define : __PTRDIFF_FMTi__ : "li"
define : __INTMAX_WIDTH__ : 64
define : __WCHAR_WIDTH__ : 32
define : __SIZE_FMTX__ : "lX"
define : __SIZE_WIDTH__ : 64
define : __SIZE_FMTo__ : "lo"
define : __SIZE_FMTu__ : "lu"
define : __HAVE_GENERIC_SELECTION : 1
define : __SIZE_FMTx__ : "lx"
define : __INTPTR_WIDTH__ : 64
define : __UINTPTR_FMTo__ : "lo"
define : __INT_FAST8_MAX__ : 127
define : __UINTMAX_WIDTH__ : 64
define : __SIG_ATOMIC_WIDTH__ : 32
define : _SYS_CDEFS_H : 1
define : __SIG_ATOMIC_MAX__ : 2147483647
define : __GLIBC_MINOR__ : 31
define : __WINT_WIDTH__ : 32
define : __UINT_FAST8_FMTx__ : "hhx"
define : __GNU_LIBRARY__ : 6
define : __UINT_FAST8_FMTX__ : "hhX"
define : __GLIBC__ : 2
define : __UINT_FAST8_FMTo__ : "hho"
define : __STDC_IEC_559_COMPLEX__ : 1
define : __UINT_FAST8_FMTu__ : "hhu"
define : __STDC_ISO_10646__ : 201706
define : __UINTPTR_FMTX__ : "lX"
define : __STDC_IEC_559__ : 1
define : __SYSCALL_WORDSIZE : 64
define : __UINT_FAST8_MAX__ : 255
define : __LONG_DOUBLE_USES_FLOAT128 : 0
define : __UINTPTR_FMTu__ : "lu"
define : __INT_FAST8_FMTd__ : "hhd"
define : _STDC_PREDEF_H : 1
define : __UINTPTR_FMTx__ : "lx"
define : __INT_FAST8_FMTi__ : "hhi"
define : __WORDSIZE_TIME64_COMPAT32 : 1
define : __UINTMAX_MAX__ : 4294967295:u32
define : __SIZE_MAX__ : 4294967295:u32
define : __UINTPTR_MAX__ : 4294967295:u32
define : __PTRDIFF_MAX__ : -1
define : __INTPTR_MAX__ : -1
define : _ATFILE_SOURCE : 1
define : __WCHAR_MAX__ : 2147483647
define : __LONG_LONG_MAX__ : 9223372036854775807:i64
define : __INTMAX_MAX__ : -1
define : __WINT_MAX__ : 4294967295:u32
define : __SIZEOF_LONG_LONG__ : 8
define : __SIZEOF_LONG_DOUBLE__ : 16
define : _POSIX_C_SOURCE : 200809
define : __USE_POSIX_IMPLICITLY : 1
define : __SIZEOF_SHORT__ : 2
define : __SIZEOF_POINTER__ : 8
define : __SIZEOF_FLOAT__ : 4
define : __SIZEOF_DOUBLE__ : 8
define : __SIZEOF_LONG__ : 8
define : _POSIX_SOURCE : 1
define : __SIZEOF_INT__ : 4
define : _DEFAULT_SOURCE : 1
define : __SIZEOF_INT128__ : 16
define : __INTMAX_FMTi__ : "li"
define : __INTMAX_FMTd__ : "ld"
define : __SIZEOF_SIZE_T__ : 8
define : __SIZEOF_PTRDIFF_T__ : 8
define : __SIZEOF_WINT_T__ : 4
define : __SIZEOF_WCHAR_T__ : 4
define : __UINTMAX_FMTX__ : "lX"
define : __UINTMAX_FMTx__ : "lx"
define : __GLIBC_USE_DEPRECATED_GETS : 0
define : __GLIBC_USE_ISOC2X : 0
define : __UINTMAX_FMTu__ : "lu"
define : __UINTMAX_FMTo__ : "lo"
define : __GLIBC_USE_DEPRECATED_SCANF : 0
define : __USE_ATFILE : 1
define : __USE_FORTIFY_LEVEL : 0
define : __USE_MISC : 1
define : __glibc_c99_flexarr_available : 1
define : __CHAR_BIT__ : 8
define : __SCHAR_MAX__ : 127
define : __INT_MAX__ : 2147483647
define : __SHRT_MAX__ : 32767
define : __LONG_MAX__ : -1
define : _IOLBF : 1
define : _IOFBF : 0
define : _IONBF : 2
define : __UINT_LEAST64_FMTu__ : "lu"
define : __OFF_T_MATCHES_OFF64_T : 1
define : __UINT_LEAST64_FMTx__ : "lx"
define : _IO_USER_LOCK : 32768
define : __INO_T_MATCHES_INO64_T : 1
define : __UINT_LEAST64_MAX__ : 4294967295:u32
define : __RLIM_T_MATCHES_RLIM64_T : 1
define : __UINT_LEAST64_FMTo__ : "lo"
define : _IO_ERR_SEEN : 32
define : __llvm__ : 1
define : __STATFS_MATCHES_STATFS64 : 1
define : __clang__ : 1
define : __clang_major__ : 12
define : _IO_EOF_SEEN : 16
define : __FD_SETSIZE : 1024
define : _BITS_TIME64_H : 1
define : __UINT_LEAST64_FMTX__ : "lX"
define : __UINT_LEAST32_FMTX__ : "X"
define : __clang_version__ : "12.0.0 (https://github.com/llvm/llvm-project/ b978a93635b584db380274d7c8963c73989944a1)"
define : __GNUC__ : 4
define : __UINT_LEAST32_FMTu__ : "u"
define : __clang_minor__ : 0
define : __UINT_LEAST32_FMTx__ : "x"
define : __clang_patchlevel__ : 0
define : __GXX_ABI_VERSION : 1002
define : __INT_LEAST64_FMTi__ : "li"
define : __ATOMIC_RELAXED : 0
define : __GNUC_MINOR__ : 2
define : __INT_LEAST64_MAX__ : -1
define : __GNUC_PATCHLEVEL__ : 1
define : __INT_LEAST64_FMTd__ : "ld"
define : __ATOMIC_RELEASE : 3
define : __INT_LEAST32_MAX__ : 2147483647
define : __ATOMIC_ACQ_REL : 4
define : __INT_LEAST32_FMTd__ : "d"
define : __ATOMIC_CONSUME : 1
define : __UINT_LEAST16_FMTX__ : "hX"
define : __ATOMIC_ACQUIRE : 2
define : __OPENCL_MEMORY_SCOPE_WORK_GROUP : 1
define : __UINT_LEAST32_MAX__ : 4294967295:u32
define : __UINT_LEAST32_FMTo__ : "o"
define : __WORDSIZE : 64
define : __ATOMIC_SEQ_CST : 5
define : __INT_LEAST32_FMTi__ : "i"
define : __OPENCL_MEMORY_SCOPE_WORK_ITEM : 0
define : __PRAGMA_REDEFINE_EXTNAME : 1
define : __INT32_FMTi__ : "i"
define : __OPENCL_MEMORY_SCOPE_SUB_GROUP : 4
define : __USE_XOPEN2K : 1
define : __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES : 3
define : __OPENCL_MEMORY_SCOPE_DEVICE : 2
define : __INT32_FMTd__ : "d"
define : __ORDER_LITTLE_ENDIAN__ : 1234
define : __CONSTANT_CFSTRINGS__ : 1
define : __OBJC_BOOL_IS_BOOL : 0
define : __VERSION__ : "Clang 12.0.0 (https://github.com/llvm/llvm-project/ b978a93635b584db380274d7c8963c73989944a1)"
define : __INT64_FMTd__ : "ld"
define : __USE_XOPEN2K8 : 1
define : __LITTLE_ENDIAN__ : 1
define : __UINT8_FMTx__ : "hhx"
define : __INT64_FMTi__ : "li"
define : __UINT8_FMTX__ : "hhX"
define : __ORDER_PDP_ENDIAN__ : 3412
define : __UINT8_FMTo__ : "hho"
define : __ORDER_BIG_ENDIAN__ : 4321
define : __UINT8_FMTu__ : "hhu"
define : _LP64 : 1
define : __LP64__ : 1
define : __STDC_UTF_16__ : 1
define : __LDBL_MAX__ : Inf:f64
define : __STDC_UTF_32__ : 1
define : __STDC_HOSTED__ : 1
define : __LDBL_MAX_10_EXP__ : 4932
define : __STDC_VERSION__ : 201710
define : __LDBL_MAX_EXP__ : 16384
define : __POINTER_WIDTH__ : 64
define : __BIGGEST_ALIGNMENT__ : 16
define : FOPEN_MAX : 16
define : __LDBL_MIN__ : 0.0:f64
define : _STDIO_H : 1
define : L_ctermid : 9
define : TMP_MAX : 238328
define : __INT8_FMTd__ : "hhd"
define : __USE_ISOC99 : 1
define : __USE_ISOC95 : 1
define : __INT8_FMTi__ : "hhi"
define : L_tmpnam : 20
define : FILENAME_MAX : 4096
define : __WINT_UNSIGNED__ : 1
define : _FEATURES_H : 1
define : _BITS_STDIO_LIM_H : 1
define : __USE_ISOC11 : 1
define : P_tmpdir : "/tmp"
define : SEEK_END : 2
define : __INT16_FMTi__ : "hi"
define : __USE_POSIX199309 : 1
define : __USE_POSIX199506 : 1
define : __USE_POSIX : 1
define : SEEK_SET : 0
define : BUFSIZ : 8192
define : __INT16_FMTd__ : "hd"
define : __USE_POSIX2 : 1
define : __UINT16_FMTu__ : "hu"
define : SEEK_CUR : 1
define : __MMX__ : 1
define : __DBL_HAS_QUIET_NAN__ : 1
define : __UINT16_FMTx__ : "hx"
define : __DBL_HAS_INFINITY__ : 1
define : __SSE_MATH__ : 1
define : __UINT16_FMTX__ : "hX"
define : __DBL_MAX_10_EXP__ : 308
define : __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 : 1
define : __DBL_MANT_DIG__ : 53
define : __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 : 1
define : __DBL_MAX__ : 179769313486231570900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0:f64
define : __UINT16_MAX__ : 65535
define : __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 : 1
define : __DBL_MAX_EXP__ : 1024
define : __INT16_MAX__ : 32767
define : __GNUC_VA_LIST : 1
define : __DBL_MIN__ : 0.0:f64
define : unix : 1
define : __UINT32_FMTu__ : "u"
define : __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 : 1
define : __LDBL_HAS_DENORM__ : 1
define : __unix__ : 1
define : __UINT32_FMTo__ : "o"
define : __LDBL_DENORM_MIN__ : 0.0:f64
define : __unix : 1
define : __linux__ : 1
define : __LDBL_DECIMAL_DIG__ : 21
define : __linux : 1
define : __LDBL_DIG__ : 18
define : linux : 1
define : __LDBL_HAS_INFINITY__ : 1
define : __gnu_linux__ : 1
define : __LDBL_EPSILON__ : 0.0:f64
define : __SIZEOF_FLOAT128__ : 16
define : __UINT8_MAX__ : 255
define : __LDBL_MANT_DIG__ : 64
define : __INT8_MAX__ : 127
define : __LDBL_HAS_QUIET_NAN__ : 1
define : __FLT_DECIMAL_DIG__ : 9
define : __amd64 : 1
define : __UINT16_FMTo__ : "ho"
define : __FLT_DIG__ : 6
define : __code_model_small__ : 1
define : __FLT_HAS_INFINITY__ : 1
define : __x86_64__ : 1
define : __amd64__ : 1
define : __FLT_EPSILON__ : 0.0
define : __FLOAT128__ : 1
define : __x86_64 : 1
define : __FLT_MANT_DIG__ : 24
define : __SEG_FS : 1
define : _____fpos_t_defined : 1
define : __FLT_HAS_QUIET_NAN__ : 1
define : __SEG_GS : 1
define : __STDC__ : 1
define : __ELF__ : 1
define : __FLT_MAX_10_EXP__ : 38
define : __FLT_MAX_EXP__ : 128
define : __FLT_MAX__ : 340282346638528859000000000000000000000.0
define : __k8 : 1
define : __k8__ : 1
define : __DBL_DENORM_MIN__ : 0.0:f64
define : __tune_k8__ : 1
define : __FLT_MIN__ : 0.0
define : __DBL_DIG__ : 15
define : __SSE2__ : 1
define : __FXSR__ : 1
define : __NO_MATH_INLINES : 1
define : __DBL_HAS_DENORM__ : 1
define : __DBL_EPSILON__ : 0.0:f64
define : __DBL_DECIMAL_DIG__ : 17
define : __SSE2_MATH__ : 1
define : __FILE_defined : 1
define : __CLANG_ATOMIC_WCHAR_T_LOCK_FREE : 2
define : __INT_LEAST16_FMTd__ : "hd"
define : __CLANG_ATOMIC_SHORT_LOCK_FREE : 2
define : __INT_LEAST16_MAX__ : 32767
define : __CLANG_ATOMIC_INT_LOCK_FREE : 2
define : __CLANG_ATOMIC_LONG_LOCK_FREE : 2
define : __INT_LEAST16_FMTi__ : "hi"
define : ____mbstate_t_defined : 1
define : __SSE__ : 1
define : _BITS_TYPES_H : 1
define : __UINT_LEAST16_FMTo__ : "ho"
define : __CLANG_ATOMIC_LLONG_LOCK_FREE : 2
define : __UINT_LEAST16_MAX__ : 65535
define : __CLANG_ATOMIC_POINTER_LOCK_FREE : 2
define : ____FILE_defined : 1
define : __UINT_LEAST16_FMTx__ : "hx"
define : __GCC_ATOMIC_BOOL_LOCK_FREE : 2
define : __UINT_LEAST16_FMTu__ : "hu"
define : __GNUC_STDC_INLINE__ : 1
define : __GCC_ATOMIC_LONG_LOCK_FREE : 2
define : __INT_LEAST8_FMTi__ : "hhi"
define : __GCC_ATOMIC_TEST_AND_SET_TRUEVAL : 1
define : __GCC_ATOMIC_LLONG_LOCK_FREE : 2
define : __UINT_LEAST8_FMTo__ : "hho"
define : __CLANG_ATOMIC_BOOL_LOCK_FREE : 2
define : __GCC_ATOMIC_POINTER_LOCK_FREE : 2
define : __UINT_LEAST8_MAX__ : 255
define : __NO_INLINE__ : 1
define : __CLANG_ATOMIC_CHAR_LOCK_FREE : 2
define : __UINT_LEAST8_FMTx__ : "hhx"
define : __FLT_EVAL_METHOD__ : 0
define : __UINTPTR_WIDTH__ : 64
define : __UINT_LEAST8_FMTu__ : "hhu"
define : __FLT_RADIX__ : 2
define : __CLANG_ATOMIC_CHAR16_T_LOCK_FREE : 2
define : __FLT_DENORM_MIN__ : 0.0
define : __CLANG_ATOMIC_CHAR32_T_LOCK_FREE : 2
define : __FLT_HAS_DENORM__ : 1
define : __UINT_LEAST8_FMTX__ : "hhX"
define : __GCC_ASM_FLAG_OUTPUTS__ : 1
define : _BITS_TYPESIZES_H : 1
define : __UINT64_FMTX__ : "lX"
define : __UINT64_FMTx__ : "lx"
define : __UINT64_MAX__ : 4294967295:u32
define : __struct_FILE_defined : 1
define : __INT64_MAX__ : -1
define : __INT_LEAST8_FMTd__ : "hhd"
define : _____fpos64_t_defined : 1
define : __INT_LEAST8_MAX__ : 127
define : __UINT32_FMTX__ : "X"
define : __GCC_ATOMIC_CHAR_LOCK_FREE : 2
define : __GCC_ATOMIC_CHAR16_T_LOCK_FREE : 2
define : __UINT32_FMTx__ : "x"
define : __GCC_ATOMIC_CHAR32_T_LOCK_FREE : 2
define : __GCC_ATOMIC_WCHAR_T_LOCK_FREE : 2
define : __INT32_MAX__ : 2147483647
define : __GCC_ATOMIC_SHORT_LOCK_FREE : 2
define : __GCC_ATOMIC_INT_LOCK_FREE : 2
define : __UINT32_MAX__ : 4294967295:u32
define : __UINT64_FMTu__ : "lu"
define : __UINT64_FMTo__ : "lo"
define : __BYTE_ORDER__ : 1234
define : stderr : PureCast$foneniseh:(mutable& (mutable@ <struct _IO_FILE>))
define : stdout : PureCast$hamosibug:(mutable& (mutable@ <struct _IO_FILE>))
define : stdin : PureCast$filobatax:(mutable& (mutable@ <struct _IO_FILE>))
define : __TIMESIZE : 64
define : __DECIMAL_DIG__ : 21
typedef : __builtin_va_list : __builtin_va_list
typedef : size_t : u64
typedef : va_list : __builtin_va_list
typedef : __gnuc_va_list : __builtin_va_list
typedef : __u_char : u8
typedef : __u_short : u16
typedef : __u_int : u32
typedef : __u_long : u64
typedef : __int8_t : i8
typedef : __uint8_t : u8
typedef : __int16_t : i16
typedef : __uint16_t : u16
typedef : __int32_t : i32
typedef : __uint32_t : u32
typedef : __int64_t : i64
typedef : __uint64_t : u64
typedef : __int_least8_t : i8
typedef : __uint_least8_t : u8
typedef : __int_least16_t : i16
typedef : __uint_least16_t : u16
typedef : __int_least32_t : i32
typedef : __uint_least32_t : u32
typedef : __int_least64_t : i64
typedef : __uint_least64_t : u64
typedef : __quad_t : i64
typedef : __u_quad_t : u64
typedef : __intmax_t : i64
typedef : __uintmax_t : u64
typedef : __dev_t : u64
typedef : __uid_t : u32
typedef : __gid_t : u32
typedef : __ino_t : u64
typedef : __ino64_t : u64
typedef : __mode_t : u32
typedef : __nlink_t : u64
typedef : __off_t : i64
typedef : __off64_t : i64
typedef : __pid_t : i32
typedef : __fsid_t : <struct >
typedef : __clock_t : i64
typedef : __rlim_t : u64
typedef : __rlim64_t : u64
typedef : __id_t : u32
typedef : __time_t : i64
typedef : __useconds_t : u32
typedef : __suseconds_t : i64
typedef : __daddr_t : i32
typedef : __key_t : i32
typedef : __clockid_t : i32
typedef : __timer_t : (opaque@ void)
typedef : __blksize_t : i64
typedef : __blkcnt_t : i64
typedef : __blkcnt64_t : i64
typedef : __fsblkcnt_t : u64
typedef : __fsblkcnt64_t : u64
typedef : __fsfilcnt_t : u64
typedef : __fsfilcnt64_t : u64
typedef : __fsword_t : i64
typedef : __ssize_t : i64
typedef : __syscall_slong_t : i64
typedef : __syscall_ulong_t : u64
typedef : __loff_t : i64
typedef : __caddr_t : (mutable@ i8)
typedef : __intptr_t : i64
typedef : __socklen_t : u32
typedef : __sig_atomic_t : i32
typedef : __mbstate_t : <struct >$2
typedef : __fpos_t : <struct _G_fpos_t>
typedef : __fpos64_t : <struct _G_fpos64_t>
typedef : __FILE : <struct _IO_FILE>
typedef : FILE : <struct _IO_FILE>
typedef : _IO_lock_t : void
typedef : off_t : i64
typedef : ssize_t : i64
typedef : fpos_t : <struct _G_fpos_t>
extern : stdin : PureCast$filobatax:(mutable& (mutable@ <struct _IO_FILE>))
extern : stdout : PureCast$hamosibug:(mutable& (mutable@ <struct _IO_FILE>))
extern : stderr : PureCast$foneniseh:(mutable& (mutable@ <struct _IO_FILE>))
extern : remove : (%1: extern remove : (opaque@ (i32 <-: ((@ i8)))))
extern : rename : (%1: extern rename : (opaque@ (i32 <-: ((@ i8) (@ i8)))))
extern : renameat : (%1: extern renameat : (opaque@ (i32 <-: (i32 (@ i8) i32 (@ i8)))))
extern : tmpfile : (%1: extern tmpfile : (opaque@ ((mutable@ <struct _IO_FILE>) <-: ())))
extern : tmpnam : (%1: extern tmpnam : (opaque@ ((mutable@ i8) <-: ((mutable@ i8)))))
extern : tmpnam_r : (%1: extern tmpnam_r : (opaque@ ((mutable@ i8) <-: ((mutable@ i8)))))
extern : tempnam : (%1: extern tempnam : (opaque@ ((mutable@ i8) <-: ((@ i8) (@ i8)))))
extern : fclose : (%1: extern fclose : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : fflush : (%1: extern fflush : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : fflush_unlocked : (%1: extern fflush_unlocked : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : fopen : (%1: extern fopen : (opaque@ ((mutable@ <struct _IO_FILE>) <-: ((@ i8) (@ i8)))))
extern : freopen : (%1: extern freopen : (opaque@ ((mutable@ <struct _IO_FILE>) <-: ((@ i8) (@ i8) (mutable@ <struct _IO_FILE>)))))
extern : fdopen : (%1: extern fdopen : (opaque@ ((mutable@ <struct _IO_FILE>) <-: (i32 (@ i8)))))
extern : fmemopen : (%1: extern fmemopen : (opaque@ ((mutable@ <struct _IO_FILE>) <-: ((opaque@ void) u64 (@ i8)))))
extern : open_memstream : (%1: extern open_memstream : (opaque@ ((mutable@ <struct _IO_FILE>) <-: ((mutable@ (mutable@ i8)) (mutable@ u64)))))
extern : setbuf : (%1: extern setbuf : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>) (mutable@ i8)))))
extern : setvbuf : (%1: extern setvbuf : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) (mutable@ i8) i32 u64))))
extern : setbuffer : (%1: extern setbuffer : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>) (mutable@ i8) u64))))
extern : setlinebuf : (%1: extern setlinebuf : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>)))))
extern : fprintf : (%1: extern fprintf : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) (@ i8) ...))))
extern : printf : (%1: extern printf : (opaque@ (i32 <-: ((@ i8) ...))))
extern : sprintf : (%1: extern sprintf : (opaque@ (i32 <-: ((mutable@ i8) (@ i8) ...))))
extern : vfprintf : (%1: extern vfprintf : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) (@ i8) (mutable@ <struct __va_list_tag>)))))
extern : vprintf : (%1: extern vprintf : (opaque@ (i32 <-: ((@ i8) (mutable@ <struct __va_list_tag>)))))
extern : vsprintf : (%1: extern vsprintf : (opaque@ (i32 <-: ((mutable@ i8) (@ i8) (mutable@ <struct __va_list_tag>)))))
extern : snprintf : (%1: extern snprintf : (opaque@ (i32 <-: ((mutable@ i8) u64 (@ i8) ...))))
extern : vsnprintf : (%1: extern vsnprintf : (opaque@ (i32 <-: ((mutable@ i8) u64 (@ i8) (mutable@ <struct __va_list_tag>)))))
extern : vdprintf : (%1: extern vdprintf : (opaque@ (i32 <-: (i32 (@ i8) (mutable@ <struct __va_list_tag>)))))
extern : dprintf : (%1: extern dprintf : (opaque@ (i32 <-: (i32 (@ i8) ...))))
extern : fscanf : (%1: extern fscanf : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) (@ i8) ...))))
extern : scanf : (%1: extern scanf : (opaque@ (i32 <-: ((@ i8) ...))))
extern : sscanf : (%1: extern sscanf : (opaque@ (i32 <-: ((@ i8) (@ i8) ...))))
extern : vfscanf : (%1: extern vfscanf : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) (@ i8) (mutable@ <struct __va_list_tag>)))))
extern : vscanf : (%1: extern vscanf : (opaque@ (i32 <-: ((@ i8) (mutable@ <struct __va_list_tag>)))))
extern : vsscanf : (%1: extern vsscanf : (opaque@ (i32 <-: ((@ i8) (@ i8) (mutable@ <struct __va_list_tag>)))))
extern : fgetc : (%1: extern fgetc : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : getc : (%1: extern getc : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : getchar : (%1: extern getchar : (opaque@ (i32 <-: ())))
extern : getc_unlocked : (%1: extern getc_unlocked : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : getchar_unlocked : (%1: extern getchar_unlocked : (opaque@ (i32 <-: ())))
extern : fgetc_unlocked : (%1: extern fgetc_unlocked : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : fputc : (%1: extern fputc : (opaque@ (i32 <-: (i32 (mutable@ <struct _IO_FILE>)))))
extern : putc : (%1: extern putc : (opaque@ (i32 <-: (i32 (mutable@ <struct _IO_FILE>)))))
extern : putchar : (%1: extern putchar : (opaque@ (i32 <-: (i32))))
extern : fputc_unlocked : (%1: extern fputc_unlocked : (opaque@ (i32 <-: (i32 (mutable@ <struct _IO_FILE>)))))
extern : putc_unlocked : (%1: extern putc_unlocked : (opaque@ (i32 <-: (i32 (mutable@ <struct _IO_FILE>)))))
extern : putchar_unlocked : (%1: extern putchar_unlocked : (opaque@ (i32 <-: (i32))))
extern : getw : (%1: extern getw : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : putw : (%1: extern putw : (opaque@ (i32 <-: (i32 (mutable@ <struct _IO_FILE>)))))
extern : fgets : (%1: extern fgets : (opaque@ ((mutable@ i8) <-: ((mutable@ i8) i32 (mutable@ <struct _IO_FILE>)))))
extern : __getdelim : (%1: extern __getdelim : (opaque@ (i64 <-: ((mutable@ (mutable@ i8)) (mutable@ u64) i32 (mutable@ <struct _IO_FILE>)))))
extern : getdelim : (%1: extern getdelim : (opaque@ (i64 <-: ((mutable@ (mutable@ i8)) (mutable@ u64) i32 (mutable@ <struct _IO_FILE>)))))
extern : getline : (%1: extern getline : (opaque@ (i64 <-: ((mutable@ (mutable@ i8)) (mutable@ u64) (mutable@ <struct _IO_FILE>)))))
extern : fputs : (%1: extern fputs : (opaque@ (i32 <-: ((@ i8) (mutable@ <struct _IO_FILE>)))))
extern : puts : (%1: extern puts : (opaque@ (i32 <-: ((@ i8)))))
extern : ungetc : (%1: extern ungetc : (opaque@ (i32 <-: (i32 (mutable@ <struct _IO_FILE>)))))
extern : fread : (%1: extern fread : (opaque@ (u64 <-: ((opaque@ void) u64 u64 (mutable@ <struct _IO_FILE>)))))
extern : fwrite : (%1: extern fwrite : (opaque@ (u64 <-: ((opaque@ void) u64 u64 (mutable@ <struct _IO_FILE>)))))
extern : fread_unlocked : (%1: extern fread_unlocked : (opaque@ (u64 <-: ((opaque@ void) u64 u64 (mutable@ <struct _IO_FILE>)))))
extern : fwrite_unlocked : (%1: extern fwrite_unlocked : (opaque@ (u64 <-: ((opaque@ void) u64 u64 (mutable@ <struct _IO_FILE>)))))
extern : fseek : (%1: extern fseek : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) i64 i32))))
extern : ftell : (%1: extern ftell : (opaque@ (i64 <-: ((mutable@ <struct _IO_FILE>)))))
extern : rewind : (%1: extern rewind : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>)))))
extern : fseeko : (%1: extern fseeko : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) i64 i32))))
extern : ftello : (%1: extern ftello : (opaque@ (i64 <-: ((mutable@ <struct _IO_FILE>)))))
extern : fgetpos : (%1: extern fgetpos : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) (mutable@ <struct _G_fpos_t>)))))
extern : fsetpos : (%1: extern fsetpos : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) (@ <struct _G_fpos_t>)))))
extern : clearerr : (%1: extern clearerr : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>)))))
extern : feof : (%1: extern feof : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : ferror : (%1: extern ferror : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : clearerr_unlocked : (%1: extern clearerr_unlocked : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>)))))
extern : feof_unlocked : (%1: extern feof_unlocked : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : ferror_unlocked : (%1: extern ferror_unlocked : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : perror : (%1: extern perror : (opaque@ (void <-: ((@ i8)))))
extern : sys_nerr : PureCast$fepahewil:(mutable& i32)
extern : sys_errlist : PureCast$gusogonuk:(mutable& (array (@ i8)))
extern : fileno : (%1: extern fileno : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : fileno_unlocked : (%1: extern fileno_unlocked : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : popen : (%1: extern popen : (opaque@ ((mutable@ <struct _IO_FILE>) <-: ((@ i8) (@ i8)))))
extern : pclose : (%1: extern pclose : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : ctermid : (%1: extern ctermid : (opaque@ ((mutable@ i8) <-: ((mutable@ i8)))))
extern : flockfile : (%1: extern flockfile : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>)))))
extern : ftrylockfile : (%1: extern ftrylockfile : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : funlockfile : (%1: extern funlockfile : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>)))))
extern : __uflow : (%1: extern __uflow : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : __overflow : (%1: extern __overflow : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) i32))))
#+end_example



** Non-standard Libraries

This works for standard libraries. But what about vendored libraries?

Here is a minimal example for loading the cross-platform windowing
etc. library GLFW:

#+begin_src scopes :tangle _bin/externc_glfw.sc
  let glfw =
      include
          "GLFW/glfw3.h"
          options
              # "-v"
              .. "-I" module-dir "/../_guix/dev/dev/include"

  let glfw-lib-path = (.. module-dir "/../_guix/dev/dev/lib/libglfw.so")

  load-library glfw-lib-path

  run-stage;
  glfw.extern.glfwInit;
#+end_src

Here we have to add some options to the ~include~ function for the
path to search for include files. These options correspond to what the
clang compiler would expect from the command line.

In this example we installed the packages using the ~guix~ package
manager in the ~_guix/dev/dev~ directory.

 ~module-dir~ gives the current directory of the module that is
 executing and doesn't include a trailing slash.





** Destructors & defer

Not really a feature in C++ but more from the Go family.

#+begin_src scopes
  defer print "end of module"

  let name = "Bob"

  defer print (.. "Goodbye " name "!")
#+end_src

#+RESULTS:
: Goodbye Bob!
: end of module

** Ownership and the Borrow Checker

See:
https://gist.github.com/radgeRayden/67b654b5bb8f3227749b5dd7a577ec4d

Namely remember when making small snippets that you can't return
unique values from a module.
