* Level 2: Things you would know if you knew C/C++

** structs

#+begin_src scopes
  using import struct
  using import String

  struct Example plain
      value : i32
      choice = false
      text : string = ""

  global example : Example
      value = 100
      text = "test"


  print example.value
  print example.text
#+end_src

#+RESULTS:
: 100
: test


#+begin_src scopes
  using import struct

  struct thing
      what : string

  let t = (thing (what = "test"))

  print t.what
#+end_src

#+RESULTS:
: test

#+begin_src scopes
  using import struct

  struct thing
      what : string
      size : u32

  let t =
      thing
          "Other thing"
          1:u32

  print t.what
  print t.size

  let d =
      thing
          size = 1:u32
          what = "Other thing"

  print d.what
  print d.size
#+end_src

#+RESULTS:
: Other thing
: 1:u32
: Other thing
: 1:u32


** Types

#+begin_src scopes
  print (typeof 'print)
  print (storageof Symbol)
  print (storagecast 'print)
#+end_src

#+RESULTS:
: Symbol
: u64
: 4809770749102710031:u64

** Const

#+begin_src scopes
  print (constant? 1)
  local a = 1
  print (constant? a)
#+end_src

#+RESULTS:
: true
: false

** Type Annotations

The return values of functions can be explicitly typed, and will be
type-checked:

#+begin_src scopes :tangle _bin/functions_returns.sc
  fn get-origin ()
      returning (_: i32 i32)

      _ 0 0

  let a b  = (get-origin)

#+end_src

#+RESULTS:

The ~returning~ statement can occur anywhere in the function
block. Types will not be cast and the annotation will be strictly
checked.


** dump

#+begin_src scopes
  fn add (a b)
      dump a b
      a + b

  add 3 4
#+end_src

#+RESULTS:

** TODO Operator Overload

** C-like Strings


#+begin_src scopes :tangle _bin/primitives_strings_extractvalue.sc
  let digits = "0123456789"

  print (digits @ 1)
#+end_src

#+RESULTS:
: 49:i8

Where the value is the int value for the char it encodes.

** TODO More Strings

** TODO Arrays

#+begin_src scopes
  let arr = ((array f32 2) 0 1)
  print arr
#+end_src

#+RESULTS:
: (arrayof f32 0.0 1.0)


#+begin_src scopes
  let arr = (arrayof f32 0 1 2 3)

  print arr
#+end_src

#+RESULTS:
: (arrayof f32 0.0 1.0 2.0 3.0)

** Tuples

In Level 1 we saw how to dynamically define tuples with ~tupleof~. You
can also declare the type in full first before instantiating.

#+begin_src scopes

  print
      ((tuple i32 f32) 0:i32 1:f32)
#+end_src

#+RESULTS:
: (tupleof 0 1.0)

#+begin_src scopes
  let tup-type = (tuple (a = i32) (b = u64))

  print (tup-type (a = 0) (b = 1:u64))
#+end_src

#+RESULTS:
: (tupleof 0 1:u64)


** Including C Functions

You can load a single function:

#+begin_src scopes :tangle _bin/externc1.sc
  let printf =
      do
          let header = (include "stdio.h")
          header.extern.printf

  printf "hello\n"
#+end_src


Or a whole module:

#+begin_src scopes :tangle _bin/externc2.sc
  let c:stdio =
      (include "stdio.h") . extern

  c:stdio.printf "hello\n"
#+end_src

Note that ~c:stdio~ is just a symbol and not special syntax. It could
have been: ~stdio~ or any other valid symbol.


If you have a newer version it is also included in the standard
library:

#+begin_src scopes :tangle _bin/externc2.sc
  let c:stdio = (import C.stdio)
  let c:string = (import C.string)
  let c:stdlib = (import C.stdlib)
#+end_src


** Non-standard Libraries

This works for standard libraries. But what about vendored libraries?

Here is a minimal example for loading the cross-platform windowing
etc. library GLFW:

#+begin_src scopes :tangle _bin/externc_glfw.sc
  let glfw =
      include
          "GLFW/glfw3.h"
          options
              # "-v"
              .. "-I" module-dir "/../_guix/dev/dev/include"

  let glfw-lib-path = (.. module-dir "/../_guix/dev/dev/lib/libglfw.so")

  load-library glfw-lib-path

  run-stage;
  glfw.extern.glfwInit;
#+end_src

Here we have to add some options to the ~include~ function for the
path to search for include files. These options correspond to what the
clang compiler would expect from the command line.

In this example we installed the packages using the ~guix~ package
manager in the ~_guix/dev/dev~ directory.

 ~module-dir~ gives the current directory of the module that is
 executing and doesn't include a trailing slash.





** defer

Not really a feature in C++ but more from the Go family.

#+begin_src scopes
  defer print "end of module"

  let name = "Bob"

  defer print (.. "Goodbye " name "!")
#+end_src

#+RESULTS:
: Goodbye Bob!
: end of module

** TODO COMMENT

- [ ] pointers and references
- [ ] constant values
- [ ] defer
