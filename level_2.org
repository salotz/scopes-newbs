** Level 2: Things you would know if you knew C/C++

*** Type Annotations

The return values of functions can be explicitly typed, and will be
type-checked:

#+begin_src scopes :tangle _bin/functions_returns.sc
  fn get-origin ()
      returning (_: i32 i32)

      _ 0 0

  let a b  = (get-origin)

#+end_src

#+RESULTS:

The ~returning~ statement can occur anywhere in the function
block. Types will not be cast and the annotation will be strictly
checked.

*** TODO Operator Overload
*** TODO More Strings

*** TODO Arrays


*** Including C Functions

You can load a single function:

#+begin_src scopes :tangle _bin/externc1.sc
  let printf =
      do
          let header = (include "stdio.h")
          header.extern.printf

  printf "hello\n"
#+end_src


Or a whole module:

#+begin_src scopes :tangle _bin/externc2.sc
  let c:stdio =
      (include "stdio.h") . extern

  c:stdio.printf "hello\n"
#+end_src

Note that ~c:stdio~ is just a symbol and not special syntax. It could
have been: ~stdio~ or any other valid symbol.


If you have a newer version it is also included in the standard
library:

#+begin_src scopes :tangle _bin/externc2.sc
  let c:stdio = (import C.stdio)
  let c:string = (import C.string)
  let c:stdlib = (import C.stdlib)
#+end_src


*** Non-standard Libraries

This works for standard libraries. But what about vendored libraries?

Here is a minimal example for loading the cross-platform windowing
etc. library GLFW:

#+begin_src scopes :tangle _bin/externc_glfw.sc
  let glfw =
      include
          "GLFW/glfw3.h"
          options
              # "-v"
              .. "-I" module-dir "/../_guix/dev/dev/include"

  let glfw-lib-path = (.. module-dir "/../_guix/dev/dev/lib/libglfw.so")

  load-library glfw-lib-path

  run-stage;
  glfw.extern.glfwInit;
#+end_src

Here we have to add some options to the ~include~ function for the
path to search for include files. These options correspond to what the
clang compiler would expect from the command line.

In this example we installed the packages using the ~guix~ package
manager in the ~_guix/dev/dev~ directory.

 ~module-dir~ gives the current directory of the module that is
 executing and doesn't include a trailing slash.




** Level 3: For Lisp/Scheme Gurus

In this section we will cover the features that are similar to Lisp
and Scheme like languages.

Scopes is after all a Scheme-like language.

*** TODO Pattern Matching

See ~match~


*** TODO

From the ~meta.md~ file in the unpublished docs.

- [ ] macros
- [ ] pattern matching
- [ ] debugging
- [ ] infix macros
- [ ] symbol prefix macros
- [ ] list hooks
- [ ] symbol hooks
- [ ] using macro libraries
- [ ] quotes
- [ ] meta-evaluation
- [ ] conditional translation

** Level 4: Going super-saiyan, Scopes trick-shots

*** Decorators


Similar to decorators in Python; Scopes has decorators to remove
levels of wrapping/indentation.

First is the ~vvv~ decorator. Think of this symbol as downward
pointing arrows.

#+begin_src scopes :tangle _bin/level_4__vvv.sc
  vvv bind a
  12

  print a
#+end_src


This is equivalent to:

#+begin_src scopes :tangle _bin/level_4__vvv.sc
  let a = 12
#+end_src

This small example makes it seem stupid, but we are kind of abusing
the return behavior to make a point. In other languages decorators
wrap only functions but in Scopes they wrap blocks, where the last
value of the block is returned.

A demonstrative, but still contrived example:

#+begin_src scopes :tangle _bin/level_4__vvv.sc
  vvv bind a
  _ 1 2

  print a
#+end_src

#+RESULTS:
: 1

#+begin_src scopes
print "hello"
#+end_src

#+RESULTS:
: hello


You can even instrument your code with it.

#+begin_src scopes
  vvv print
  let
      a = 3
      b = 4
#+end_src

#+RESULTS:
: 3 4

#+begin_src scopes :tangle _bin/level_4__decorator.sc
  @@ bind a
  let c = 12

  print a

  # not an error
  print c
#+end_src

*** Code Transformation

(From the unpublished docs)

| Order | Stage       | From                    | To                 | Macro System |
|-------+-------------+-------------------------+--------------------+--------------|
|     1 | Parsing     | Data Interchange Format | S-Expression Tree  |              |
|     2 | Expansion   | S-Expression Tree       | Untyped Scopes AST | Sugar        |
|     3 | Checking    | Untyped Scopes AST      | Typed Scopes IL    | Spice        |
|     4 | Translation | Typed Scopes IL         | LLVM IR / SPIR-V   |              |
|     5 | Execution   | LLVM IR / SPIR-V        | Program Output     |              |


** Level 5: ...
