* Level 2: Things you would know if you knew C/C++


** Cross Cutting Concepts

Scopes can be said to to have the following features/properties which
will be discussed throughout this section and assumed to have
knowledge of.

These are that Scopes:

1. supports *multi-stage programming* where the compiler can stay
   online during exectution,
2. supports many zero-cost abstractions when possible (such as compile
   time computations), and
3. is statically typed,
4. is low level and concerned with memory layout and management directly,
5. supports the C ABI directly.
6. has a borrow checker.

We will discuss everything but the borrow checker in detail in this
section. Borrow checking and lifetime management is a somewhat more
advanced feature than is available in C/C++; made popular by the Rust
programming language. It is unavoidable that we must confront it when
using C/C++ equivalent functionality in this level, however we avoid
discussion of direct manipulation of its features or constructs meant
to directly leverage it.

Instead we will describe the general behavior and the minimum amount
of annotations and code needed to "make it happy" and avoid
errors. This is good because ultimately it helps us make less errors
and the overhead on the code is rather minimal when compared to
writing C/C++ code.

*** Compilation & Code Generation

**** What is a Multi-Stage Compiler?

Perhaps most important to frame Scopes' behavior and most different
from other languages (besides Common Lisp) is that the Scopes compiler
is considered to be a "multi-stage" compiler. To understand this lets
consider the more common types of compilation you may have experience
with.

In languages like C/C++ you invoke the compiler once and emit your
finished program which can then be executed. No new code can be
generated for the program. This is called "ahead of time" or an AOT
compiler.

Languages like Java are both AOT compiled as well as "just in time"
(JIT) compiled. This is a big topic with many nuances but suffice to
say that the runtime engine waits to compile your code until it sees
fit (typically only just before it actually needs to be run, hence the
name). In this model the compiler stays online during execution but is
not explicitly controlled by the programmer. Instead the runtime will
have extensive intelligent features to try to determine the best time
to compile code.

In dynamic languages there are flavors of all in between and including
those running on a virtual machine without compilation (to machine
code) happening at all.

Scope's follows a third model in which the compiler stays online
during execution (like a JIT compiler) but is explicitly controlled by
the programmer. In the later point this is actually closer to an AOT
compiler if you consider that your build system is actually a
programming language, just a different language. This is called a
Multi-Stage Compiler. There are very few multi-stage compilers in the
wild but include heavyweights like Common Lisp.

All the types of compilers have their benefits and drawbacks. 

AOT compilation can produce extremely lean and predictable executables
that are suitable for constrained environments like microcontrollers
or as operating system kernels. The drawback of being AOT only however
is that you lose a lot of dynamicism and flexibility. This is why
there are so many higher-level languages implemented on top of C/C++
that allow for more flexible execution of code without having to
invoke a monolithic compiler like GCC. Furthermore, its very common to
have a program with a plethora of compilation flags that determine
run-time characteristics. If you want to turn a feature on or off, you
may have to recompile which can be time consuming and difficult to do
and deploy. 

Relatedly, an AOT model typically assumes the existence of a "build
system". These are the Make/Autotools and CMakes of the world that
everyone loves to hate for good reason. These things have the
difficult job of orchestrating the not-so-programmable monolothic
compilers (like GCC). While not all build systems suck, they generally
do as they are surprisingly hard to get right and easy to
underestimate the complexity. They are also typically an afterthought
to the actual code itself. The need for a "build system" is present in
any language but for those with less complicated compilation needs are
primarily around just to do things like packaging.

JIT compilers (and interpreted languages in general) on the other hand
make code compilation completely transparent to the user. There is no
build system because there really isn't even a compiler to invoke. The
compiler exists completely in the runtime. JIT compilers are very
advanced pieces of technology which are more similar to magic than an
AOT compiler. You don't know how and when its compiling your code but
most of the time its doing a pretty damn good job of it. JIT compilers
are really good at squeezing performance for free out of code written
in languages that don't typically excel at low-level
optimizations. Notable examples are the HotSpot VM for Java, V8 for
Javascript, and PyPy for Python. They can make code for these
languages run at speeds approaching hand optimized ones in C/C++ for
many use cases.

Sounds too good to be true, and it is if your doing anything that has
real-time constraints or must do manual memory management. The latter
is a result of the incremental compilation that typically requires an
automatic garbage collector (GC) in order to keep everything
straight. While there are a few reasons to not use a GC one of the
main ones is that garbage collectors will need to suspend the
operation of your program in order to do their work. This process
cannot be controlled in your program and so if you have real-time
constraints you cannot guarantee that you will meet these constraints
because the GC may pause at any moment. This feeds into the other
probem with real-time and JIT compilers. As indicated in the name a
JIT compiler will compile your code only when it is needed. To do this
it needs to suspend operation of your program to compile the
code. Again you cannot control this and invalidates any real-time
constraints you may have. Furthermore, a JIT compiler may often
compile your code multiple times in different scenarios. For instance
if it thinks this code will only be run once it may not take the time
to optimize it heavily, but if it thinks it will be run a lot may
pause longer to do more optimizations. So not only will you miss
real-time deadlines but you can't even be sure your code will run as
fast as you need it to. Compare that to the AOT case in which
optimizations levels are explicitly controlled and the cost for them
is paid up-front and before your code ever even executes.

The multi-stage compiler is kind of the "have your cake and eat it
too" position. You get the flexibility of a JIT compiler (or
interpreted language) and the predictability of an AOT compiler all in
one package.

How does it reconcile these two modes of compilation? By organizing
your code into stages and allowing explicit control of the compiler in
the language itself. Its really a nice middel ground between the two
extremes of the other compilers. In AOT you really only have one
stage, that being all your code when you compile it into machine
code. In a JIT compiler you have a multitudinous fractal of stages,
small to large pieces of code being compiled all over the place at
random times. In a multi-stage program you will have something in
between.

Lets make this a little more concrete before moving on. In Scopes
compilation can be triggered in a couple different ways.

1. When a module is imported
2. When the ~run-stage~ function is run
3. When "including" C code via the Clang bridge
4. By running the various ~compile*~ commands:
   - ~compile~ which returns a function pointer to the compiled code.
   - ~compile-object~ for machine code for a target
     platform/architecture into object files
   - ~compile-glsl~ for compiling to GLSL
   - ~compile-spirv~ for compiling to SPIR-V

The "stage" in multi-stage programming is controlled by the
~run-stage~ symbol. This signals to the Scopes compiler something akin
to a translation unit (TU) in C/C++. The code before a ~run-stage~
will be run/compiled and injected into the code of the next stage.

Here is a minimal example:

#+begin_src scopes
  fn help (msg)
      print "Help!" msg

  run-stage;

  help "Me"
#+end_src

#+RESULTS:
: Help! Me

In this example there isn't any reason to actually separate this code
into two stages. It will be too difficult to explain at this moment
when exactly a new stage is needed and so will be mentioned when
needed.

Whats important to takeaway from this is that when and where your code
is compiled is very straightforward compared to a JIT
compiler. Compilation just occurs of each stage in the order they are
declared and only when the previous stage finishes execution.

There are drawbacks to a multi-stage compiler as well perhaps. First
it inherits the large run-time size of a JIT compiler as it needs the
compiler to run the stages. Currently that means bringing along LLVM
for the ride which is quite hefty.

Its worth noting that Scopes can replicate the behavior of an AOT
compiler and generate objects that require no runtime & compiler other
than a normal C run time. However, this is a little tricky and subtle
topic and so we leave it for later. So while its possible it certainly
isn't the most important use case, at least yet.

Another potential perceived drawback is the complexity or
unfamiliarity of a multi-stage compiler. Programmers are used to AOT
compilers & build systems or interpreted languages. Using a
multi-stage compiler brings in a host of new concepts and commands
that must be learned before the language can be used
effectively. Hopefully, for the curious looking for maximum
expressivity and performance this will be no issue.

**** Compilation Steps & Code Generation

Now that we have contextualized broadly how the Scopes compiler
operates on source code its time to dive a little deeper into the
specifics of the compilation itself. This aspect is also considerably
different from other programming languages and is worth understanding
at least at a surface level.

The following table summarizes the steps of compilation and execution
of Scopes code:

| Order | Step       | From                          | To                      | Macro System |
|-------+-------------+-------------------------------+-------------------------+--------------|
|     1 | Parsing     | Data Interchange Format (SLN) | S-Expression Tree       |              |
|     2 | Expansion   | S-Expression Tree             | Untyped Scopes AST      | Sugar        |
|     3 | Checking    | Untyped Scopes AST            | Typed Scopes IL         | Spice        |
|     4 | Translation | Typed Scopes IL               | LLVM IR / SPIR-V / GLSL |              |
|     5 | Execution   | LLVM IR / SPIR-V              | Program Output          |              |

This table will be very important to understand later concepts in
metaprogramming and the two macro systems (sugars and spices of which
we briefly met in Level 1).

However for now its enough to look at steps 3 through 5.

In a scripting language like python you would probably only have steps
1 and 5, and perhaps 4 depending on the runtime.

In a language with metaprogramming (i.e. macros) you add in step 2
which allows for generating new code. C/C++ both have this with
different sophistication steps.

For a statically typed language you add in step 3 which is to do type
checking.

Step 4 is common to both Scopes and C/C++ however it is different in
that this is controlled directly in the code rather than through a
compiler and/or build system as discussed in the last section.

**** TODO COMMENT Code Generation

After having covered the steps in compilation we can discuss the
different types of code that is generated by Scopes.

*** Constant vs Dynamic Values

*Constant* compile-time values are the dual to *dynamic* run-time
values in that constant values can be known before compilation to
machine code.

The compile-time vs run-time distinction in Scopes is considerably
different than in most purely AOT compiled languages like C/C++ and is
a major feature of the language. This is due to the multi-stage aspect
of the compiler.

In every stage it is both compile-time and run-time and so to say
generically something is a "compile-time" computation is tautological
and useless.

However, the compile-time of one stage is the run-time of the next
stage and so in a relative sense the distinction still carries some
sense.

Before we consider the implications of "constant" values on our code
lets distinguish between constant and dynamic values.

Scopes does provide some features to actually test for "constant-ness"
in ~constant?~ which we can test on some basic things.

#+begin_src scopes
  print "i32?" (constant? 1)

  let a = 1
  print "let?" (constant? a)

  local b = 1
  print "local?" (constant? b)

  global c = 1
  print "global?" (constant? c)

#+end_src

#+RESULTS:
: i32? true
: let? true
: local? false
: global? false


So we can see that primitives like ~1~ and those assigned to symbols
by ~let~ are constant but ~local~ and ~global~ defined variables are
not.

Lets try some other ones:

#+begin_src scopes
  print "list?" (constant? '(a b))
  print "symbol?" (constant? 'Hello)

  print "cast value?" (constant? (1 as f32))

  using import UTF-8
  print "char?" (constant? (char32 "a"))

  fn hello ()
      print "hello"

  print "function?" (constant? hello)

  print "string?" (constant? "hello")

  print "rawstring?" (constant? ("hello" as rawstring))

  import Map
  print "module?" (constant? Map)

  print "tuple?" (constant? (tupleof 1 2:f32 "hello"))

  using import String
  print "String?"(constant? (String "hello"))

#+end_src

#+RESULTS:
#+begin_example
list? true
symbol? true
cast value? true
char? true
function? true
string? true
rawstring? true
module? true
tuple? true
String? false
#+end_example

All these are constant except a ~String~ object, which as we will see
later is heap allocated.

But these are all somewhat static objects. What about if we look at
the inputs and outputs of functions. In this example the function is
just the identity function and just returns the value:

#+begin_src scopes
  fn nop (thing)
      thing

  let b = 3

  print "b:" (constant? b)
  print "nop b:" (constant? (nop b))
#+end_src

#+RESULTS:
: b: true
: nop b: false

And we can see that a constant value passed through a function is no
longer a constant.

But why? The reason is that because functions are like little black
boxes the compiler cannot reason about what the output of the function
will be.

But in reality we know that this function is so simple that the
compiler really could figure out what this is doing (and probably
eliminate it).

Like what is the difference between calling our function and just
presenting the value itself? Nothing.

In Scopes we have a way to express functions not as black-boxes but
moreso as ways to copy-paste code around so that the compiler would be
able to figure these things out. You might call these
"white-boxes". The simplest is the ~inline~ declaration which we
introduced as an alternative syntax for defining functions.

Here is the above example rewritten with ~inline~:

#+begin_src scopes
  inline nop (thing)
      thing

  let b = 3

  print "b:" (constant? b)
  print "nop b:" (constant? (nop b))
#+end_src

#+RESULTS:
: b: true
: nop b: true

We can see now the result is constant after passing through this
inline "function".

In reality whats happening is that the body of the inline function is
more-or-less copied into the call-site of the inline. I.e. it would
look like this:

#+begin_src scopes
  inline nop (thing)
      thing

  let b = 3

  print "b:" (constant? b)

  # print "nop b:" (constant? (nop b))
  # replaced with
  print "nop b:" (constant? b)
#+end_src

#+RESULTS:
: b: true
: nop b: true

Which then makes sense why its also constant.

You might recognize this as a kind of macro, like in the C/C++
preprocessor which can copy-paste code around. However, this macro is
different in that it is *hygenic*. Meaning that it still obeys scoping
rules like a normal function. Lets test this out:

#+begin_src scopes
  local a = 1
  local b = 2

  inline increment (a)
      a + 1

  print (increment b)
  print a
#+end_src

#+RESULTS:
: 3
: 1

Notice that the variable ~a~ in the outer scope did not get
incremented.

We will have much more to say on macros and metaprogramming in higher
levels but we will cover the topics that a C/C++ programmer might
achieve through the use of the preprocessor in this level.

We only bring it up here because of its relevance to constant
values. Macros tend to produce constant values because they are run
and generate code before any actual "run-time" code is run. Its as if
you had written the code yourself in an editor.

What else can we do that is constant? A comprehensive answer is not
given here but we can show a few things which are:

#+begin_src scopes
  let a = 1
  let b = 2

  print "addition?" (constant? (b + a))
  print "exponentiation?" (constant? (a ^ b))


  let s0 = "hello"
  let s1 = "world"

  print "string concatenation?" (constant? (.. s0 s1))
#+end_src

#+RESULTS:
: addition? true
: exponentiation? true
: string concatenation? true

---

TODO: explain the "static" variants of everything.

- ~static-if~


*** Static Types

That Scopes is statically typed (like C/C++) is one of the biggest
differences between a "dynamically typed" scripting language like
Python.

Here we will show how to get information on types, use types, and how
types relate to the run time, but later in "Type Definitions" we will
cover how to create your own types as this is not essential to being
able to use the language -- although very useful.

**** Type Symbols & Type Information

First it helps to be able to figure out information on the types of
values or what symbols correspond to types. By convention types are
commonly CamelCased for complex types outside of the builtins, but is
by no means necessarily true.

We have already covered one of these ~typeof~ but lets recap:

#+begin_src scopes
  print (typeof 'print)
  print (typeof true)
  print (typeof 1)
#+end_src

#+RESULTS:
: Symbol
: bool
: i32

Some other useful functions related to the type are ~qualifiersof~ &
~storageof~ which will give you more information about a value
including things like references etc.

#+begin_src scopes
  using import String

  print "let:"
  let let-str = (String "hello")
  print "    typeof:" (typeof let-str)
  print "    qualifiersof:" (qualifiersof let-str)
  print "    storageof:" (storageof let-str)

  print "local:"
  local local-str = (String "hello")
  print "    typeof:" (typeof local-str)
  print "    qualifiersof:" (qualifiersof local-str)
  print "    storageof:" (storageof local-str)

  print "global:"
  global global-str = (String "hello")
  print "    typeof:" (typeof global-str)
  print "    qualifiersof:" (qualifiersof global-str)
  print "    storageof:" (storageof global-str)
#+end_src

#+RESULTS:
#+begin_example
let:
    typeof: <GrowingString i8>
    qualifiersof: (uniqueof <GrowingString i8> 1003)
    storageof: (tuple (_items = (mutable@ i8)) (_count = usize) (_capacity = usize))
local:
    typeof: <GrowingString i8>
    qualifiersof: (uniqueof (mutable& (storage = 'Function) <GrowingString i8>) 1009)
    storageof: (tuple (_items = (mutable@ i8)) (_count = usize) (_capacity = usize))
global:
    typeof: <GrowingString i8>
    qualifiersof: (viewof (mutable& (storage = 'Private) <GrowingString i8>) 999)
    storageof: (tuple (_items = (mutable@ i8)) (_count = usize) (_capacity = usize))
#+end_example

You will notice that the ~qualifiersof~ information is different for all of them.

The meaning behind all of these will be discussed later, as it does
have to do with the type system to some degree (and specifically the
borrow checker) but for now we will stick to the common meaning of the
words types.

**** Type Annotations

In this section we cover how to add explicitly annotate initialization
statements with types similar to how you would in C/C++

In Level 1 we were mostly able to ignore having to declare types at
all. This is because Scopes is able to infer types. Being able to
infer types is not a unique feature of Scopes and other languages,
particularly those from the functional languages like OCaml, have type
inference.

However, the mainstream statically typed languages like C/C++ or Rust
all do not do type inference, meaning you must -- almost -- always
declare your types; even if the compiler could have done it for you.

While these seems annoying there is a utility in this in that
everything is annotated explicitly so you don't get confused when
something gets inferred to a type you didn't intend to.

In Scopes you can choose to let the compiler infer types for you (when
it can) or explicitly declare them.

Because the syntax is often optimized for automatic type inference the
explicit type declarations typically are available as optional extra
syntax.

Here is an example of how to annotate the type for a variable
declaration:

#+begin_src scopes
  let int : i32 = 0:i32
  print int
#+end_src

#+RESULTS:
: 0

You can also declare the variable and type without initializing it:

#+begin_src scopes
  local count : i32

  print count
  print (typeof count)
  count = 4
  print count
  print (typeof count)
#+end_src

#+RESULTS:
: 0
: i32
: 4
: i32

TODO there are other syntaxes as well which should be covered.

**** Function Types

Function types are a bit more complicated. We can annotate them easily
enough with the ~returning~ syntax:

#+begin_src scopes
  fn nop-num (num)
      returning (_: i32)

      num

  print (nop-num 0)

  print (typeof nop-num)
#+end_src

#+RESULTS:
: 0
: Closure

First lets explain some of the syntax. ~returning~ is a builtin, ~_:~
is a special type called ~Arguments~, and the rest of the values in
the list are the types of the arguments you will be returning.

Then notice how that for a function instead of getting the full type
signature we only get the symbol ~Closure~, which indicates that it is
a compile-time closure.

To get the concrete type signature we need to use the tool
~static-typify~:

#+begin_src scopes
  fn nop-num (num)
      returning (_: i32)

      return num

  let func = (static-typify nop-num i32)

  print "Closure result" (nop-num 0)
  print "static-typified result" (func 0)
  print ""
  print "function:" func
  print "function type:" (typeof func)

  # TODO: you can also cast functions directly
  # nop-num as (@ (function))
#+end_src

#+RESULTS:

The arguments to ~static-typify~ are the function template ~Closure~
and the types of the arguments you want to instantiate it as.

The return value of ~static-typify~ is also a function that you can
actually call as well, as shown in the example.

However the type signature of the function is now known and made
explicit: ~(opaque@ (i32 <-: (i32)))~ which means "an opaque pointer
to a function that accepts an ~i32~ and returns an ~i32~".

(Pointers and opaque pointers will be discussed later.)

Here we just introduce the basics of how functions are typed but,
there is a lot more to say about function templates and their uses
which will be discussed later.

**** Error Types

Because of Scopes special handling of errors by "patching" the return
types we can also statically define the types of errors which can be
raised using the ~raising~ syntax:

#+begin_src scopes
  fn raise-error ()
      raising Error

      if true
          error "error"

      else
          "no error"

  print (static-typify raise-error)
#+end_src

#+RESULTS:
: (%1: fn raise-error () : (opaque@ (string <-: () raises Error)) (%2: branch #unnamed : string (...)) (return %2)):(opaque@ (string <-: () raises Error))

We can see now a much more complicated type signature (formatted for clarity):

#+begin_example
(%1: fn raise-error () : (opaque@ (string <-: () raises Error)) 
(%2: branch #unnamed : string (...)) (return %2)):(opaque@ (string <-: () raises Error))
#+end_example

*** Low Level Memory Management & Layout

**** Pointers

In normal usage of Scopes you will be much less concerned with
pointers than you would be writing C/C++ code.

However they will still come up when either you are explicitly
managing memory when creating a datastructure on the heap or when
interfacing with C/C++ code that returns pointers as part of its API.

Normally you would receive pointers either from C code or memory
allocation. We will discuss memory allocation later so to start this
off we need to obtain a pointer to observe.

To do this we will obtain the pointer to a ~local~ value using the ~&~
operator.

#+begin_src scopes
  local a = 3
  print (& a)
  print (typeof (& a))
  print (qualifiersof (& a))
  print (storageof (& a))
#+end_src

#+RESULTS:
: $rirorukerosubil:(mutable@ (storage = 'Function) i32)
: $rirorukerosubil:(mutable@ (storage = 'Function) i32)
: (mutable@ (storage = 'Function) i32)
: (mutable@ (storage = 'Function) i32)
: (mutable@ (storage = 'Function) i32)

The representation of the value should look something like this:
~$rironedapoxiken:(mutable@ (storage = 'Function) i32)~

Or if you execute on the REPL:
~$rironedapoxiken:(mutable@ (storage = Private) i32)~

Looking at the ~typeof~ and ~storageof~ portion of this we can see
that the type is ~mutable@~ indicating it is a pointer, and
specifically a "mutable" pointer.

The ~(storage = 'Function)~ indicates the "storage class" where
~'Function~ means it is stack storage and, as we will see, ~'Private~
means global memory. 

This is intended to support code generation to targets like SPIR-V
primarily.

And at the right-hand-side we see ~i32~ indicating that the value
being pointed to is an ~i32~ integer.

Also notice that we needed a ~local~ value. Because ~let~ is immutable
we cannot directly access the memory, which would imply that we could
edit it.

That means we can also get pointers from ~global~ values:

#+begin_src scopes
  global b = 4
  print &b
#+end_src

#+RESULTS:
: Global$genaroked:(mutable@ (storage = 'Private) i32)

Here we also see the alternative syntax for getting the pointer to a
value: ~&b~.

The representation should be something like this:
~Global$genaroked:(mutable@ (storage = 'Private) i32)~.

Very similar except that it has a "Global" indicator at the beginning
and is the ~'Private~ storage class.


We mentioned that the pointers we were dealing with above were
"mutable" pointers. You can check if something is mutable using the
~mutable?~ keyword:

#+begin_src scopes
  local a = 1
  global b = 2

  print "a mutable?:" (mutable? &a)
  print "b mutable?:" (mutable? &b)
  print "b mutable?:" (mutable? &c)
#+end_src

#+RESULTS:

You can express the types of pointers in a couple ways for both
immutable constant and mutable pointers:

#+begin_src scopes

  # these are equivalent
  let p = (pointer i32)
  let ap = (@ i32)

  let mp = (mutable pointer i32)

  print "p:" (typeof p) p
  print "  mutable?:" (mutable? p)

  print "ap:" (typeof ap) ap
  print "  mutable?:" (mutable? p)

  print "mp:" (typeof mp) mp
  print "  mutable?:" (mutable? mp)
#+end_src

#+RESULTS:
: p: type (@ i32)
:   mutable?: false
: ap: type (@ i32)
:   mutable?: false
: mp: type (mutable@ i32)
:   mutable?: true

Alternatively there are other ways to write a mutable pointer:

#+begin_src scopes
  print (mutable@ i32)
  print (mutable (@ i32))
#+end_src

#+RESULTS:
: (mutable@ i32)
: (mutable@ i32)

And finally there is a third kind of pointer which is the "opaque"
pointer. This indicates that there is no storage for the type.

Here is an example:

#+begin_src scopes
  print (pointer (type T))

  let opaque-ptr = (pointer (type V))
  print (opaque-ptr)
#+end_src

#+RESULTS:
: (opaque@ T)
: (nullof (opaque@ V)):(opaque@ V)

Opaque pointers are common when dealing with function pointers as we
have seen previously with ~static-typify~.

***** Getting Pointers

****** Null Pointer

The simplest pointer that we can conjure out of thin air is the
so-called "null" pointer which points to nothing.

#+begin_src scopes
  let nul-ptr = (nullof (@ i32))
  print nul-ptr

  let nul-ptr = (nullof (mutable@ i32))
  print nul-ptr
#+end_src

#+RESULTS:
: (nullof (@ i32)):(@ i32)
: (nullof (mutable@ i32)):(mutable@ i32)

Null pointers are equal to the special value ~null~:

#+begin_src scopes
  let nul-ptr = (nullof (@ i32))

  if (nul-ptr == null)
      print "nul-ptr is null"
  else
      print "nul-ptr is not null"

  local a = 1

  if (&a == null)
      print "&a is null"
  else
      print "&a is not null"
#+end_src

#+RESULTS:
: nul-ptr is null
: &a is not null


You can cast the pointers to the address which is a ~u64~. We can see
that the address of the null pointer is 0.

#+begin_src scopes
  print ((nullof i32) as u64)
#+end_src

#+RESULTS:
: 0:u64

For other values we can see different numbers:

#+begin_src scopes
  local a = 3

  print (&a as u64)
#+end_src

#+RESULTS:
: 140737172878068:u64

****** Stack & Global Pointers

Above we showed how to get pointers from ~local~ (stack created with
~alloca~) and ~global~ (data segment) allocated values. Because these
are not heap allocated they do have some extra rules surrounding their
use.

Global pointers can be accessed anywhere since the values are in the
data segment of the program:

#+begin_src scopes
  fn test ()
      global b = 2
      print (deref (@ &b))
      &b

  local b = (test)

  print (@ b)
#+end_src

#+RESULTS:
: 2
: 2


However local variables are on the stack so if you return a pointer to
a local that was allocated on an upper framestack then it will be
invalidated outside the scope:

#+begin_src scopes
  fn test ()
      local b = 2
      print (@ &b)
      &b

  let b = (test)

  print b
  print (@ b)
#+end_src

#+RESULTS:
: 2
: $riropihuwohinim:(mutable@ (storage = 'Function) i32)
: 32712

****** TODO COMMENT Heap Pointers

Perhaps the more common use of pointers is in actual memory management
in which memory is allocated on the heap. Functions that allocated
memory will return pointers as the results to these.

We will see more of memory management but here we will show how to get
pointers from them.

#+begin_src scopes
#+end_src

***** References

TODO

Then there are reference types which are different from pointer types:

#+begin_src scopes
  print (& i32)
  print (mutable (& i32))
#+end_src


**** COMMENT Heap Memory Allocation

**** COMMENT Constructors & Destructors

**** COMMENT defer and other lifetime management



** Major Constructs & Routines
*** Tuples

In Level 1 we saw how to dynamically define tuples with ~tupleof~. You
can also declare the type in full first before instantiating.

#+begin_src scopes

  print
      ((tuple i32 f32) 0:i32 1:f32)
#+end_src

#+RESULTS:
: (tupleof 0 1.0)

#+begin_src scopes
  let tup-type = (tuple (a = i32) (b = u64))

  print (tup-type (a = 0) (b = 1:u64))
#+end_src

#+RESULTS:
: (tupleof 0 1:u64)

*** Strings

There are two common types of strings in Scopes which is necessary for
C compatibility. This might be simplified in the future but
nonetheless its useful to understand the difference between them.

**** Scopes Strings

The vanilla string in Scopes is the type ~string~. This is what you
get from the primitive form.

#+begin_src scopes
  let digits = "0123456789"

  print (typeof digits)
#+end_src

#+RESULTS:
: string

You can retrieve elements (characters) from this string.

Where the value is the int value for the char (~i8~) it encodes.

#+begin_src scopes
  let digits = "0123456789"

  print (typeof (digits @ 1))
  print (digits @ 1)

#+end_src

#+RESULTS:
: i8
: 49:i8


The other kind of string is similar to the ~Array~ type previously
discussed. It is allocated on the heap and can grow in size.

It is provided in the standard library module ~String~:

#+begin_src scopes
  using import String

  let str = (String "Hello")
  let str = ("Hello" as String)

  print (typeof str)
#+end_src

#+RESULTS:
: <GrowingString i8>

You will notice that the type of ~String~ is only ~<GrowingString i8>~. 

In the future their may be support for similar constructs like
~FixedString~ and parametric types.

It has similar methods as ~Array~:

#+begin_src scopes
  using import String

  local str = (String "Hello")

  print ('capacity str)
  'append str " there sir"
  print ('capacity str)

  print str

#+end_src

#+RESULTS:
: 10:usize
: 27:usize
: Hello there sir
: <GrowingString i8>
: (uniqueof (mutable& (storage = 'Function) <GrowingString i8>) 1005)

**** C-like Strings

These are null-terminated strings that are compatible with C-strings.

They can be constructed using the ~rawstring~ type.

#+begin_src scopes
  let cstring = ("hello" as rawstring)

  print (typeof cstring)
#+end_src

#+RESULTS:
: (@ i8)

In keeping with how strings are implemented in C, this is really just
a pointer to an array of characters (~i8~) as we can see from the
above type.



**** Putting Them Together

This is perhaps the biggest "wart" in Scopes that most users will
encounter and it is there for a good reason: compatibility with C.

Hating on C strings is a very common thing to do, but because
maintaining a 1:1 correspondance with C is a very high priority it
must be dealt with. Thankfully Scopes provides some great tools for
working with this complication.

Also, you may not actually have to deal with ~rawstring~ very often in
your code. Only in the places where you interface with C code will it
be a problem.

In practice you can cast `rawstring` to the appropriate Scopes type
and move on.

Here are some other notes on converting between the string types.

When declaring a string literal, because it is constant, a cast via
~as~ is zero-cost and the ~string~ type for the literal is never
instantiated.

E.g.:

#+begin_src scopes
  "hello" as rawstring

  using import String
  "hello" as String
#+end_src

You can also convert a ~String~ to a ~rawstring~ easily:

#+begin_src scopes
  using import String

  ("hello" as String) as rawstring
#+end_src

#+RESULTS:

However to convert a rawstring to a String you will need to construct
it directly.

#+begin_src scopes
  using import String

  let rstr = ("hello" as rawstring)

  let str = (String rstr 5)

  # or get the length dynamically using the string C lib
  import C.string
  let str = (String rstr (C.string.strlen rstr))

#+end_src

#+RESULTS:

The last thing you might want to convert to a string fairly often (and
especially when interacting with the C standard library) is an array
of char to a string.

This can be done as follows:

#+begin_src scopes
  using import String

  # Must be local because we need a pointer to it
  local arr = (arrayof i8 0 1 2 3)

  # pass a pointer to the array and the length of the array
  let str = (String (& arr) (countof arr))
#+end_src


**** Encodings & Conversion

In addition to converting between the string types you will also at
some point need to deal with encodings and converting between arrays
of bytes/ints and strings.

For this there is the ~UTF-8~ module in the standard library for which
we already saw the use of the ~char32~ function.

The encoding (ints to string) and decoding (string to ints) functions
are currently only implemented as generators; which while very useful
are a little cumbersome to use if you aren't familiar with generators
and collectors yet.

So we suggest simply making a wrapper function that will do the
conversion for you without generators:

#+begin_src scopes
  using import itertools
  let utf = (import UTF-8)

  fn utf8-encode (arr)
      ->>
          arr
          utf.encoder
          string.collector ((countof arr) * (sizeof i32))

  local decoded-string = (arrayof i32 63:i32 97:i32)
  print (utf8-encode decoded-string)

  # single charactar encode
  fn char-encode (ch)
      local arr = (arrayof i32 ch)
      (utf8-encode arr)

  print (char-encode 63:i32)
#+end_src

#+RESULTS:
: ?a
: ?


TODO make the decoder since there is no default collector for arrays.

*** Structs

Structs are a similar construction as in C/C++, however they are
different in that they aren't a concept built into the core language
and instead are provided in the standard library.

Here is an example of defining a struct type:

#+begin_src scopes
  using import struct

  struct Example
      value : i32
      choice = false
      text : string = ""

#+end_src

First we import the symbols in the struct module (i.e. ~struct~) and
then we define the fields.

Fields can be declared in 3 ways:

1. with a type only (which must be provided upon construction)
2. with only a default value which the type will be inferred
3. both a type and a default value, which must match

In the syntax used above there will be a new symbol defined as
~Example~.

#+begin_src scopes
  using import struct

  let Example =
      struct
          value : i32
          choice = false
          text : string = ""

#+end_src

#+RESULTS:

#+begin_src scopes

  # 1. C-ish looking declaration
  local example : Example
      value = 100
      text = "test"

  # 2. Assignment "scopes-style"
  local example =
      Example
          value = 100
          text = "test"

  print example.value
  print example.text

#+end_src


Just to emphasize that we are still in Scopes and that you can still
use all the parens you want to make them:

#+begin_src scopes
  using import struct

  struct thing
      what : string

  let t = (thing (what = "test"))

  print t.what
#+end_src

#+RESULTS:
: test

#+begin_src scopes
  using import struct

  struct thing
      what : string
      size : u32

  let t =
      thing
          "Other thing"
          1:u32

  print t.what
  print t.size

  let d =
      thing
          size = 1:u32
          what = "Other thing"

  print d.what
  print d.size
#+end_src

#+RESULTS:
: Other thing
: 1:u32
: Other thing
: 1:u32

*** Arrays

**** C-style Arrays

First we must talk about the C-style arrays.

#+begin_src scopes
  let arr = ((array f32 2) 0 1)
  print arr
#+end_src

#+RESULTS:
: (arrayof f32 0.0 1.0)


#+begin_src scopes
  let arr = (arrayof f32 0 1 2 3)

  print arr
#+end_src

#+RESULTS:
: (arrayof f32 0.0 1.0 2.0 3.0)


#+begin_src scopes
  let arr = (arrayof f32 0 1 2 3)

  print (arr @ 1)
#+end_src

#+RESULTS:
: 1.0

Array of structs

#+begin_src scopes
  using import struct

  struct Dog
      name : string
      bark : string = "woof"
      height : f32

  let d0 =
      Dog
          "Fido"
          "Bow! Wow!"
          43

  let d1 =
      Dog
          "Max"
          "Wong! Wong!"
          56

  # array type can't be accessed with dynamically generated indices
  # (like from the for loop below) because you could easily go beyond
  # the bounds of the array
  local dogs = (arrayof Dog d0 d1)

  for idx in (range 2)
      # access the struct members of the array elements
      print ((dogs @ idx) . name) "says" ((dogs @ idx) . bark)

  for idx in (range 2)
      # access the struct members of the array elements
      ((dogs @ idx) . name) = "George"

      print ((dogs @ idx) . name)


  local dog-arr = (array Dog 2)
  for i in (range 2)
      (dog-arr @ i) =
          Dog
              "Max"
              "Wong! Wong!"
              56

#+end_src

#+RESULTS:

**** Arrays

#+begin_src scopes
  using import Array

  # Fixed size array
  local arr = ((Array i32 10))
  print (typeof arr)

  # Growing array (e.g. C++ vector)
  local arr = ((Array i32))
  print (typeof arr)

  # You can explicitly use GrowingArray or FixedArray types
  local garr = ((GrowingArray i32))
  local farr = ((FixedArray i32 10))

  # add a value to the array
  let element = ('append arr 0)

  print element

  print (countof arr)
  print (arr @ 0)

  # assign to a particular location
  arr @ 0 = 2
  print (arr @ 0)

  # TODO
  # insert values in between
  # 'append arr 4
  # 'insert arr 1 3

  print "last:" ('last arr)
  print "pop:" ('pop arr)

  # WARNING: segfault, no last element
  # print "last:" ('last arr)

  # remove
  'append arr 0
  'append arr 1

  'remove arr 0

  print arr

  # you can swap values
  print "Before Swap"

  'append arr 0
  print (arr @ 0)
  print (arr @ 1)

  print "After Swap"
  'swap arr 0 1

  print (arr @ 0)
  print (arr @ 1)

  # # reverse
  # print "reverse"

  # arr = ('reverse arr)
  # print (arr @ 0)
  # print (arr @ 1)

  # # sort
  # print "sort"
  # 'sort arr
  # print (arr @ 0)
  # print (arr @ 1)


  # remove all values in the array
  'clear arr
  print (countof arr)

  # WARNING: segfault if you try to access values that aren't there
  #
  # arr @ 0

  # get the capacity of the array, when this is exceeded it will be
  # expanded
  print "capacity:" ('capacity arr)

  # add capacity + 1 elements
  for i in (range 5)
      'append arr i

  # capacity is expanded
  print "capacity:" ('capacity arr)

  # again
  for i in (range 6)
      'append arr (i + 5)
  print "capacity:" ('capacity arr)

  # etc.

  # fixed arrays have the capacity you give them
  local arr = ((Array i32 10))

  print "capacity:" ('capacity arr)


  # You can use 'resize' or 'reserve' to force a particular capacity

  # resize will initialize the elements
  print "resize"

  local arr = ((Array i32))

  print "capacity:" ('capacity arr)
  print "countof:" (countof arr)
  'resize arr 10
  print "capacity:" ('capacity arr)
  print "countof:" (countof arr)

  print (arr @ 0)

  # reserve will not initialize the elements

  print "reserve"
  local arr = ((Array i32))

  print "capacity:" ('capacity arr)
  print "countof:" (countof arr)
  'reserve arr 10
  print "capacity:" ('capacity arr)
  print "countof:" (countof arr)

  # WARNING: segfault, not initialized
  # print (arr @ 0)


  # casting to generators
#+end_src

#+RESULTS:


You can also construct arrays with initial values:

#+begin_src scopes
  using import Array

  let things = ((Array string) "a" "b" "c")

  let numbers =
      (Array f32)
          4.0
          3.0

  print (numbers @ 0)

  using import struct

  struct Dog plain
      name : string
      bark : string = "woof"
      height : f32

  let dogs =
      (Array Dog)
          Dog
              "Fido"
              "Bow! Wow!"
              43
          Dog
              "Max"
              "Wong! Wong!"
              56


  print ((dogs @ 0) . name)
#+end_src

#+RESULTS:
: 4.0
: Fido


**** Some Examples

***** Looping Over Arrays

Arrays can be cast to generators implicitly so we can loop over them
directly:

#+begin_src scopes
  using import Array

  let things = ((Array string) "a" "b" "c")

  for thing in things
      print thing
#+end_src

#+RESULTS:
: a
: b
: c

A common pattern in programming languages is to loop over a range of
values with an index.

In "C-style" you would use a for-loop with an increment counter and
then access the data from the array you want to iterate over.

In Scopes you can do this if you know everything statically/constant:

#+begin_src scopes
  using import Array

  let array_size = 3

  let things = ((Array string array_size) "a" "b" "c")

  # print (things @ 0)

  loop (idx = 0)

      if (idx < array_size)

          print (.. (tostring idx) ": " (things @ idx))

          repeat (idx + 1)
      else
          break idx

  ;
#+end_src

#+RESULTS:
: 0: a
: 1: b
: 2: c


If you don't know the length of the array you can do something like
this:

#+begin_src scopes
  using import Array

  local things = ((Array string) "a" "b" "c")

  for idx in (range (countof things))
      print (.. (tostring idx) ": " (things @ idx))
#+end_src

#+RESULTS:
: 0: a
: 1: b
: 2: c

However, here you have a potential to go out-of-bounds with the loop
because the ~range~ is not constant and computed at run time. I.e. if
it was ~(range 4)~ you would get a segfault.

Notice also that to make this work we needed to make the ~things~ a
mutable variable with ~local~.

So this isn't really a recommended way to do things.

Similar to how you would do this in Python you can use the ~zip~
generator from ~itertools~:

#+begin_src scopes
  using import itertools
  using import Array

  let things = ((Array string) "a" "b" "c")

  for idx thing in (zip (range (countof things)) things)
      print (.. (tostring idx) ": " thing)

#+end_src

#+RESULTS:
: 0: a
: 1: b
: 2: c


*** Scopes (not the language)

TODO


*** VarArgs

TODO


*** Function Templates

*** Option

*** Enum and Union Types

We have already introduced Enums but there are some more details that
are relevant to this level.

First is that there is a "plain" version of enums, which is quite
different in terms of API. This plain version primarily exists to
interface with C code.

#+begin_src scopes
  using import enum

  enum Things1
      A
      B

  enum Things2 plain
      A
      B

  print Things2.A
  print (typeof Things2.A)

  print "superof Things1:" (superof Things1)
  print "superof Things2:" (superof Things2)

  # INVALID
  # print (Things1.A == 0)
  print (Things1.A.Literal == 0)

  print (Things2.A == 0)
#+end_src

#+RESULTS:
: A
: Things2
: Things2
: superof Things1: Enum
: superof Things2: CEnum
: true
: true

From this we see that the supertype is different and is a subtype of
~CEnum~ instead of ~Enum~.

Second we see that we don't need to explicitly get the ~Literal~
value for comparisons to work.


**** Enums for Polymorphic Exceptions

#+begin_src scopes
  using import enum

  enum Errors
      A
      B

  try
      if true
          raise Errors.A
      else
          raise Errors.B
  except (e)
      print e
#+end_src

#+RESULTS:
: enum-field<A:Nothing=0>


** Interacting with C Code

Scopes was specifically designed to be ABI compatible with C and has
extensive support for doing so.

You may actually find that its easier to run C code from inside
Scopes, no joke!

Additionally it is possible to compile Scopes code as an object file
which can be used from C code.

*** Including C Functions

If you have a newer version of Scopes the following modules are
included the standard library already since they are commonly used:

#+begin_src scopes :tangle _bin/externc2.sc
  import C.stdio
  import C.string
  import C.stdlib
  import C.socket
#+end_src

For the other libraries you will need to manually include them. This
is a fairly common thing to do in Scopes for interfacing with external
libraries. The C standard library functions are easy to work with in
the tutorial since they are available on all systems, but the method
generalizes and we will see how to do this later.


To load the header for a non-builtin C standard library you will need
to use the ~include~ function which returns a Scope.

#+begin_src scopes
  let stdio = (include "stdio.h")
#+end_src

#+RESULTS:

Then you will need to access the actual symbols from this Scope.

The following sub-scopes are available for the different kinds of
symbols in a C file:

- enum
- union
- extern
- typedef
- const
- define
- struct

#+begin_src scopes
  let stdio = (include "stdio.h")
  for k v in stdio (print k)
#+end_src

#+RESULTS:
: struct
: union
: enum
: define
: const
: typedef
: extern

A common pattern is to dump these all into the same scope for easier
access:

TODO: for now it just prints all of them.

#+begin_src scopes
  fn print_header_symbols (header-scope)
      # TODO: convert to a merge algorithm

      for symbol-key symbol-scope in header-scope

          # we must "unbox" the Scope since 'header' is a Scope and values
          # are "boxed" meaning they can have any type. To unbox is to tell
          # the compiler "hey this is of this type" since we know this is true
          let symbol-scope = (symbol-scope as Scope)

          loop (sub-key sub-value idx = ('next symbol-scope -1))
              if (idx == -1)
                  break;

              print symbol-key ":" sub-key ":" sub-value
              # 'bind merge-scope sub-key sub-value

              'next symbol-scope idx


  let header = (print_header_symbols (include "stdio.h"))

#+end_src

#+RESULTS:
#+begin_example
struct : _G_fpos_t : <struct _G_fpos_t>
struct : _G_fpos64_t : <struct _G_fpos64_t>
struct : _IO_FILE : <struct _IO_FILE>
struct : _IO_marker : <struct _IO_marker>
struct : _IO_codecvt : <struct _IO_codecvt>
struct : _IO_wide_data : <struct _IO_wide_data>
struct : __va_list_tag : <struct __va_list_tag>
define : __UINT_FAST16_FMTu__ : "hu"
define : __UINT_FAST16_FMTo__ : "ho"
define : __UINT_FAST16_MAX__ : 65535
define : __INT_FAST16_FMTi__ : "hi"
define : __INT_FAST16_FMTd__ : "hd"
define : __INT_FAST16_MAX__ : 32767
define : __UINT_FAST32_MAX__ : 4294967295:u32
define : __INT_FAST32_FMTi__ : "i"
define : __INT_FAST32_FMTd__ : "d"
define : __INT_FAST32_MAX__ : 2147483647
define : __UINT_FAST16_FMTX__ : "hX"
define : __UINT_FAST16_FMTx__ : "hx"
define : __INT_FAST64_FMTi__ : "li"
define : __GLIBC_USE_IEC_60559_FUNCS_EXT : 0
define : __INT_FAST64_FMTd__ : "ld"
define : __INT_FAST64_MAX__ : -1
define : __UINT_FAST32_FMTX__ : "X"
define : __UINT_FAST32_FMTx__ : "x"
define : __GLIBC_USE_IEC_60559_TYPES_EXT : 0
define : __UINT_FAST32_FMTu__ : "u"
define : __UINT_FAST32_FMTo__ : "o"
define : __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X : 0
define : __FINITE_MATH_ONLY__ : 0
define : __GLIBC_USE_LIB_EXT2 : 0
define : __UINT_FAST64_FMTX__ : "lX"
define : __UINT_FAST64_FMTx__ : "lx"
define : __UINT_FAST64_FMTu__ : "lu"
define : __GLIBC_USE_IEC_60559_BFP_EXT_C2X : 0
define : __UINT_FAST64_FMTo__ : "lo"
define : __UINT_FAST64_MAX__ : 4294967295:u32
define : __GLIBC_USE_IEC_60559_BFP_EXT : 0
define : __INTPTR_FMTd__ : "ld"
define : __INTPTR_FMTi__ : "li"
define : __PTRDIFF_WIDTH__ : 64
define : __PTRDIFF_FMTd__ : "ld"
define : __PTRDIFF_FMTi__ : "li"
define : __INTMAX_WIDTH__ : 64
define : __WCHAR_WIDTH__ : 32
define : __SIZE_FMTX__ : "lX"
define : __SIZE_WIDTH__ : 64
define : __SIZE_FMTo__ : "lo"
define : __SIZE_FMTu__ : "lu"
define : __HAVE_GENERIC_SELECTION : 1
define : __SIZE_FMTx__ : "lx"
define : __INTPTR_WIDTH__ : 64
define : __UINTPTR_FMTo__ : "lo"
define : __INT_FAST8_MAX__ : 127
define : __UINTMAX_WIDTH__ : 64
define : __SIG_ATOMIC_WIDTH__ : 32
define : _SYS_CDEFS_H : 1
define : __SIG_ATOMIC_MAX__ : 2147483647
define : __GLIBC_MINOR__ : 31
define : __WINT_WIDTH__ : 32
define : __UINT_FAST8_FMTx__ : "hhx"
define : __GNU_LIBRARY__ : 6
define : __UINT_FAST8_FMTX__ : "hhX"
define : __GLIBC__ : 2
define : __UINT_FAST8_FMTo__ : "hho"
define : __STDC_IEC_559_COMPLEX__ : 1
define : __UINT_FAST8_FMTu__ : "hhu"
define : __STDC_ISO_10646__ : 201706
define : __UINTPTR_FMTX__ : "lX"
define : __STDC_IEC_559__ : 1
define : __SYSCALL_WORDSIZE : 64
define : __UINT_FAST8_MAX__ : 255
define : __LONG_DOUBLE_USES_FLOAT128 : 0
define : __UINTPTR_FMTu__ : "lu"
define : __INT_FAST8_FMTd__ : "hhd"
define : _STDC_PREDEF_H : 1
define : __UINTPTR_FMTx__ : "lx"
define : __INT_FAST8_FMTi__ : "hhi"
define : __WORDSIZE_TIME64_COMPAT32 : 1
define : __UINTMAX_MAX__ : 4294967295:u32
define : __SIZE_MAX__ : 4294967295:u32
define : __UINTPTR_MAX__ : 4294967295:u32
define : __PTRDIFF_MAX__ : -1
define : __INTPTR_MAX__ : -1
define : _ATFILE_SOURCE : 1
define : __WCHAR_MAX__ : 2147483647
define : __LONG_LONG_MAX__ : 9223372036854775807:i64
define : __INTMAX_MAX__ : -1
define : __WINT_MAX__ : 4294967295:u32
define : __SIZEOF_LONG_LONG__ : 8
define : __SIZEOF_LONG_DOUBLE__ : 16
define : _POSIX_C_SOURCE : 200809
define : __USE_POSIX_IMPLICITLY : 1
define : __SIZEOF_SHORT__ : 2
define : __SIZEOF_POINTER__ : 8
define : __SIZEOF_FLOAT__ : 4
define : __SIZEOF_DOUBLE__ : 8
define : __SIZEOF_LONG__ : 8
define : _POSIX_SOURCE : 1
define : __SIZEOF_INT__ : 4
define : _DEFAULT_SOURCE : 1
define : __SIZEOF_INT128__ : 16
define : __INTMAX_FMTi__ : "li"
define : __INTMAX_FMTd__ : "ld"
define : __SIZEOF_SIZE_T__ : 8
define : __SIZEOF_PTRDIFF_T__ : 8
define : __SIZEOF_WINT_T__ : 4
define : __SIZEOF_WCHAR_T__ : 4
define : __UINTMAX_FMTX__ : "lX"
define : __UINTMAX_FMTx__ : "lx"
define : __GLIBC_USE_DEPRECATED_GETS : 0
define : __GLIBC_USE_ISOC2X : 0
define : __UINTMAX_FMTu__ : "lu"
define : __UINTMAX_FMTo__ : "lo"
define : __GLIBC_USE_DEPRECATED_SCANF : 0
define : __USE_ATFILE : 1
define : __USE_FORTIFY_LEVEL : 0
define : __USE_MISC : 1
define : __glibc_c99_flexarr_available : 1
define : __CHAR_BIT__ : 8
define : __SCHAR_MAX__ : 127
define : __INT_MAX__ : 2147483647
define : __SHRT_MAX__ : 32767
define : __LONG_MAX__ : -1
define : _IOLBF : 1
define : _IOFBF : 0
define : _IONBF : 2
define : __UINT_LEAST64_FMTu__ : "lu"
define : __OFF_T_MATCHES_OFF64_T : 1
define : __UINT_LEAST64_FMTx__ : "lx"
define : _IO_USER_LOCK : 32768
define : __INO_T_MATCHES_INO64_T : 1
define : __UINT_LEAST64_MAX__ : 4294967295:u32
define : __RLIM_T_MATCHES_RLIM64_T : 1
define : __UINT_LEAST64_FMTo__ : "lo"
define : _IO_ERR_SEEN : 32
define : __llvm__ : 1
define : __STATFS_MATCHES_STATFS64 : 1
define : __clang__ : 1
define : __clang_major__ : 12
define : _IO_EOF_SEEN : 16
define : __FD_SETSIZE : 1024
define : _BITS_TIME64_H : 1
define : __UINT_LEAST64_FMTX__ : "lX"
define : __UINT_LEAST32_FMTX__ : "X"
define : __clang_version__ : "12.0.0 (https://github.com/llvm/llvm-project/ b978a93635b584db380274d7c8963c73989944a1)"
define : __GNUC__ : 4
define : __UINT_LEAST32_FMTu__ : "u"
define : __clang_minor__ : 0
define : __UINT_LEAST32_FMTx__ : "x"
define : __clang_patchlevel__ : 0
define : __GXX_ABI_VERSION : 1002
define : __INT_LEAST64_FMTi__ : "li"
define : __ATOMIC_RELAXED : 0
define : __GNUC_MINOR__ : 2
define : __INT_LEAST64_MAX__ : -1
define : __GNUC_PATCHLEVEL__ : 1
define : __INT_LEAST64_FMTd__ : "ld"
define : __ATOMIC_RELEASE : 3
define : __INT_LEAST32_MAX__ : 2147483647
define : __ATOMIC_ACQ_REL : 4
define : __INT_LEAST32_FMTd__ : "d"
define : __ATOMIC_CONSUME : 1
define : __UINT_LEAST16_FMTX__ : "hX"
define : __ATOMIC_ACQUIRE : 2
define : __OPENCL_MEMORY_SCOPE_WORK_GROUP : 1
define : __UINT_LEAST32_MAX__ : 4294967295:u32
define : __UINT_LEAST32_FMTo__ : "o"
define : __WORDSIZE : 64
define : __ATOMIC_SEQ_CST : 5
define : __INT_LEAST32_FMTi__ : "i"
define : __OPENCL_MEMORY_SCOPE_WORK_ITEM : 0
define : __PRAGMA_REDEFINE_EXTNAME : 1
define : __INT32_FMTi__ : "i"
define : __OPENCL_MEMORY_SCOPE_SUB_GROUP : 4
define : __USE_XOPEN2K : 1
define : __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES : 3
define : __OPENCL_MEMORY_SCOPE_DEVICE : 2
define : __INT32_FMTd__ : "d"
define : __ORDER_LITTLE_ENDIAN__ : 1234
define : __CONSTANT_CFSTRINGS__ : 1
define : __OBJC_BOOL_IS_BOOL : 0
define : __VERSION__ : "Clang 12.0.0 (https://github.com/llvm/llvm-project/ b978a93635b584db380274d7c8963c73989944a1)"
define : __INT64_FMTd__ : "ld"
define : __USE_XOPEN2K8 : 1
define : __LITTLE_ENDIAN__ : 1
define : __UINT8_FMTx__ : "hhx"
define : __INT64_FMTi__ : "li"
define : __UINT8_FMTX__ : "hhX"
define : __ORDER_PDP_ENDIAN__ : 3412
define : __UINT8_FMTo__ : "hho"
define : __ORDER_BIG_ENDIAN__ : 4321
define : __UINT8_FMTu__ : "hhu"
define : _LP64 : 1
define : __LP64__ : 1
define : __STDC_UTF_16__ : 1
define : __LDBL_MAX__ : Inf:f64
define : __STDC_UTF_32__ : 1
define : __STDC_HOSTED__ : 1
define : __LDBL_MAX_10_EXP__ : 4932
define : __STDC_VERSION__ : 201710
define : __LDBL_MAX_EXP__ : 16384
define : __POINTER_WIDTH__ : 64
define : __BIGGEST_ALIGNMENT__ : 16
define : FOPEN_MAX : 16
define : __LDBL_MIN__ : 0.0:f64
define : _STDIO_H : 1
define : L_ctermid : 9
define : TMP_MAX : 238328
define : __INT8_FMTd__ : "hhd"
define : __USE_ISOC99 : 1
define : __USE_ISOC95 : 1
define : __INT8_FMTi__ : "hhi"
define : L_tmpnam : 20
define : FILENAME_MAX : 4096
define : __WINT_UNSIGNED__ : 1
define : _FEATURES_H : 1
define : _BITS_STDIO_LIM_H : 1
define : __USE_ISOC11 : 1
define : P_tmpdir : "/tmp"
define : SEEK_END : 2
define : __INT16_FMTi__ : "hi"
define : __USE_POSIX199309 : 1
define : __USE_POSIX199506 : 1
define : __USE_POSIX : 1
define : SEEK_SET : 0
define : BUFSIZ : 8192
define : __INT16_FMTd__ : "hd"
define : __USE_POSIX2 : 1
define : __UINT16_FMTu__ : "hu"
define : SEEK_CUR : 1
define : __MMX__ : 1
define : __DBL_HAS_QUIET_NAN__ : 1
define : __UINT16_FMTx__ : "hx"
define : __DBL_HAS_INFINITY__ : 1
define : __SSE_MATH__ : 1
define : __UINT16_FMTX__ : "hX"
define : __DBL_MAX_10_EXP__ : 308
define : __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 : 1
define : __DBL_MANT_DIG__ : 53
define : __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 : 1
define : __DBL_MAX__ : 179769313486231570900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0:f64
define : __UINT16_MAX__ : 65535
define : __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 : 1
define : __DBL_MAX_EXP__ : 1024
define : __INT16_MAX__ : 32767
define : __GNUC_VA_LIST : 1
define : __DBL_MIN__ : 0.0:f64
define : unix : 1
define : __UINT32_FMTu__ : "u"
define : __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 : 1
define : __LDBL_HAS_DENORM__ : 1
define : __unix__ : 1
define : __UINT32_FMTo__ : "o"
define : __LDBL_DENORM_MIN__ : 0.0:f64
define : __unix : 1
define : __linux__ : 1
define : __LDBL_DECIMAL_DIG__ : 21
define : __linux : 1
define : __LDBL_DIG__ : 18
define : linux : 1
define : __LDBL_HAS_INFINITY__ : 1
define : __gnu_linux__ : 1
define : __LDBL_EPSILON__ : 0.0:f64
define : __SIZEOF_FLOAT128__ : 16
define : __UINT8_MAX__ : 255
define : __LDBL_MANT_DIG__ : 64
define : __INT8_MAX__ : 127
define : __LDBL_HAS_QUIET_NAN__ : 1
define : __FLT_DECIMAL_DIG__ : 9
define : __amd64 : 1
define : __UINT16_FMTo__ : "ho"
define : __FLT_DIG__ : 6
define : __code_model_small__ : 1
define : __FLT_HAS_INFINITY__ : 1
define : __x86_64__ : 1
define : __amd64__ : 1
define : __FLT_EPSILON__ : 0.0
define : __FLOAT128__ : 1
define : __x86_64 : 1
define : __FLT_MANT_DIG__ : 24
define : __SEG_FS : 1
define : _____fpos_t_defined : 1
define : __FLT_HAS_QUIET_NAN__ : 1
define : __SEG_GS : 1
define : __STDC__ : 1
define : __ELF__ : 1
define : __FLT_MAX_10_EXP__ : 38
define : __FLT_MAX_EXP__ : 128
define : __FLT_MAX__ : 340282346638528859000000000000000000000.0
define : __k8 : 1
define : __k8__ : 1
define : __DBL_DENORM_MIN__ : 0.0:f64
define : __tune_k8__ : 1
define : __FLT_MIN__ : 0.0
define : __DBL_DIG__ : 15
define : __SSE2__ : 1
define : __FXSR__ : 1
define : __NO_MATH_INLINES : 1
define : __DBL_HAS_DENORM__ : 1
define : __DBL_EPSILON__ : 0.0:f64
define : __DBL_DECIMAL_DIG__ : 17
define : __SSE2_MATH__ : 1
define : __FILE_defined : 1
define : __CLANG_ATOMIC_WCHAR_T_LOCK_FREE : 2
define : __INT_LEAST16_FMTd__ : "hd"
define : __CLANG_ATOMIC_SHORT_LOCK_FREE : 2
define : __INT_LEAST16_MAX__ : 32767
define : __CLANG_ATOMIC_INT_LOCK_FREE : 2
define : __CLANG_ATOMIC_LONG_LOCK_FREE : 2
define : __INT_LEAST16_FMTi__ : "hi"
define : ____mbstate_t_defined : 1
define : __SSE__ : 1
define : _BITS_TYPES_H : 1
define : __UINT_LEAST16_FMTo__ : "ho"
define : __CLANG_ATOMIC_LLONG_LOCK_FREE : 2
define : __UINT_LEAST16_MAX__ : 65535
define : __CLANG_ATOMIC_POINTER_LOCK_FREE : 2
define : ____FILE_defined : 1
define : __UINT_LEAST16_FMTx__ : "hx"
define : __GCC_ATOMIC_BOOL_LOCK_FREE : 2
define : __UINT_LEAST16_FMTu__ : "hu"
define : __GNUC_STDC_INLINE__ : 1
define : __GCC_ATOMIC_LONG_LOCK_FREE : 2
define : __INT_LEAST8_FMTi__ : "hhi"
define : __GCC_ATOMIC_TEST_AND_SET_TRUEVAL : 1
define : __GCC_ATOMIC_LLONG_LOCK_FREE : 2
define : __UINT_LEAST8_FMTo__ : "hho"
define : __CLANG_ATOMIC_BOOL_LOCK_FREE : 2
define : __GCC_ATOMIC_POINTER_LOCK_FREE : 2
define : __UINT_LEAST8_MAX__ : 255
define : __NO_INLINE__ : 1
define : __CLANG_ATOMIC_CHAR_LOCK_FREE : 2
define : __UINT_LEAST8_FMTx__ : "hhx"
define : __FLT_EVAL_METHOD__ : 0
define : __UINTPTR_WIDTH__ : 64
define : __UINT_LEAST8_FMTu__ : "hhu"
define : __FLT_RADIX__ : 2
define : __CLANG_ATOMIC_CHAR16_T_LOCK_FREE : 2
define : __FLT_DENORM_MIN__ : 0.0
define : __CLANG_ATOMIC_CHAR32_T_LOCK_FREE : 2
define : __FLT_HAS_DENORM__ : 1
define : __UINT_LEAST8_FMTX__ : "hhX"
define : __GCC_ASM_FLAG_OUTPUTS__ : 1
define : _BITS_TYPESIZES_H : 1
define : __UINT64_FMTX__ : "lX"
define : __UINT64_FMTx__ : "lx"
define : __UINT64_MAX__ : 4294967295:u32
define : __struct_FILE_defined : 1
define : __INT64_MAX__ : -1
define : __INT_LEAST8_FMTd__ : "hhd"
define : _____fpos64_t_defined : 1
define : __INT_LEAST8_MAX__ : 127
define : __UINT32_FMTX__ : "X"
define : __GCC_ATOMIC_CHAR_LOCK_FREE : 2
define : __GCC_ATOMIC_CHAR16_T_LOCK_FREE : 2
define : __UINT32_FMTx__ : "x"
define : __GCC_ATOMIC_CHAR32_T_LOCK_FREE : 2
define : __GCC_ATOMIC_WCHAR_T_LOCK_FREE : 2
define : __INT32_MAX__ : 2147483647
define : __GCC_ATOMIC_SHORT_LOCK_FREE : 2
define : __GCC_ATOMIC_INT_LOCK_FREE : 2
define : __UINT32_MAX__ : 4294967295:u32
define : __UINT64_FMTu__ : "lu"
define : __UINT64_FMTo__ : "lo"
define : __BYTE_ORDER__ : 1234
define : stderr : PureCast$foneniseh:(mutable& (mutable@ <struct _IO_FILE>))
define : stdout : PureCast$hamosibug:(mutable& (mutable@ <struct _IO_FILE>))
define : stdin : PureCast$filobatax:(mutable& (mutable@ <struct _IO_FILE>))
define : __TIMESIZE : 64
define : __DECIMAL_DIG__ : 21
typedef : __builtin_va_list : __builtin_va_list
typedef : size_t : u64
typedef : va_list : __builtin_va_list
typedef : __gnuc_va_list : __builtin_va_list
typedef : __u_char : u8
typedef : __u_short : u16
typedef : __u_int : u32
typedef : __u_long : u64
typedef : __int8_t : i8
typedef : __uint8_t : u8
typedef : __int16_t : i16
typedef : __uint16_t : u16
typedef : __int32_t : i32
typedef : __uint32_t : u32
typedef : __int64_t : i64
typedef : __uint64_t : u64
typedef : __int_least8_t : i8
typedef : __uint_least8_t : u8
typedef : __int_least16_t : i16
typedef : __uint_least16_t : u16
typedef : __int_least32_t : i32
typedef : __uint_least32_t : u32
typedef : __int_least64_t : i64
typedef : __uint_least64_t : u64
typedef : __quad_t : i64
typedef : __u_quad_t : u64
typedef : __intmax_t : i64
typedef : __uintmax_t : u64
typedef : __dev_t : u64
typedef : __uid_t : u32
typedef : __gid_t : u32
typedef : __ino_t : u64
typedef : __ino64_t : u64
typedef : __mode_t : u32
typedef : __nlink_t : u64
typedef : __off_t : i64
typedef : __off64_t : i64
typedef : __pid_t : i32
typedef : __fsid_t : <struct >
typedef : __clock_t : i64
typedef : __rlim_t : u64
typedef : __rlim64_t : u64
typedef : __id_t : u32
typedef : __time_t : i64
typedef : __useconds_t : u32
typedef : __suseconds_t : i64
typedef : __daddr_t : i32
typedef : __key_t : i32
typedef : __clockid_t : i32
typedef : __timer_t : (opaque@ void)
typedef : __blksize_t : i64
typedef : __blkcnt_t : i64
typedef : __blkcnt64_t : i64
typedef : __fsblkcnt_t : u64
typedef : __fsblkcnt64_t : u64
typedef : __fsfilcnt_t : u64
typedef : __fsfilcnt64_t : u64
typedef : __fsword_t : i64
typedef : __ssize_t : i64
typedef : __syscall_slong_t : i64
typedef : __syscall_ulong_t : u64
typedef : __loff_t : i64
typedef : __caddr_t : (mutable@ i8)
typedef : __intptr_t : i64
typedef : __socklen_t : u32
typedef : __sig_atomic_t : i32
typedef : __mbstate_t : <struct >$2
typedef : __fpos_t : <struct _G_fpos_t>
typedef : __fpos64_t : <struct _G_fpos64_t>
typedef : __FILE : <struct _IO_FILE>
typedef : FILE : <struct _IO_FILE>
typedef : _IO_lock_t : void
typedef : off_t : i64
typedef : ssize_t : i64
typedef : fpos_t : <struct _G_fpos_t>
extern : stdin : PureCast$filobatax:(mutable& (mutable@ <struct _IO_FILE>))
extern : stdout : PureCast$hamosibug:(mutable& (mutable@ <struct _IO_FILE>))
extern : stderr : PureCast$foneniseh:(mutable& (mutable@ <struct _IO_FILE>))
extern : remove : (%1: extern remove : (opaque@ (i32 <-: ((@ i8)))))
extern : rename : (%1: extern rename : (opaque@ (i32 <-: ((@ i8) (@ i8)))))
extern : renameat : (%1: extern renameat : (opaque@ (i32 <-: (i32 (@ i8) i32 (@ i8)))))
extern : tmpfile : (%1: extern tmpfile : (opaque@ ((mutable@ <struct _IO_FILE>) <-: ())))
extern : tmpnam : (%1: extern tmpnam : (opaque@ ((mutable@ i8) <-: ((mutable@ i8)))))
extern : tmpnam_r : (%1: extern tmpnam_r : (opaque@ ((mutable@ i8) <-: ((mutable@ i8)))))
extern : tempnam : (%1: extern tempnam : (opaque@ ((mutable@ i8) <-: ((@ i8) (@ i8)))))
extern : fclose : (%1: extern fclose : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : fflush : (%1: extern fflush : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : fflush_unlocked : (%1: extern fflush_unlocked : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : fopen : (%1: extern fopen : (opaque@ ((mutable@ <struct _IO_FILE>) <-: ((@ i8) (@ i8)))))
extern : freopen : (%1: extern freopen : (opaque@ ((mutable@ <struct _IO_FILE>) <-: ((@ i8) (@ i8) (mutable@ <struct _IO_FILE>)))))
extern : fdopen : (%1: extern fdopen : (opaque@ ((mutable@ <struct _IO_FILE>) <-: (i32 (@ i8)))))
extern : fmemopen : (%1: extern fmemopen : (opaque@ ((mutable@ <struct _IO_FILE>) <-: ((opaque@ void) u64 (@ i8)))))
extern : open_memstream : (%1: extern open_memstream : (opaque@ ((mutable@ <struct _IO_FILE>) <-: ((mutable@ (mutable@ i8)) (mutable@ u64)))))
extern : setbuf : (%1: extern setbuf : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>) (mutable@ i8)))))
extern : setvbuf : (%1: extern setvbuf : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) (mutable@ i8) i32 u64))))
extern : setbuffer : (%1: extern setbuffer : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>) (mutable@ i8) u64))))
extern : setlinebuf : (%1: extern setlinebuf : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>)))))
extern : fprintf : (%1: extern fprintf : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) (@ i8) ...))))
extern : printf : (%1: extern printf : (opaque@ (i32 <-: ((@ i8) ...))))
extern : sprintf : (%1: extern sprintf : (opaque@ (i32 <-: ((mutable@ i8) (@ i8) ...))))
extern : vfprintf : (%1: extern vfprintf : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) (@ i8) (mutable@ <struct __va_list_tag>)))))
extern : vprintf : (%1: extern vprintf : (opaque@ (i32 <-: ((@ i8) (mutable@ <struct __va_list_tag>)))))
extern : vsprintf : (%1: extern vsprintf : (opaque@ (i32 <-: ((mutable@ i8) (@ i8) (mutable@ <struct __va_list_tag>)))))
extern : snprintf : (%1: extern snprintf : (opaque@ (i32 <-: ((mutable@ i8) u64 (@ i8) ...))))
extern : vsnprintf : (%1: extern vsnprintf : (opaque@ (i32 <-: ((mutable@ i8) u64 (@ i8) (mutable@ <struct __va_list_tag>)))))
extern : vdprintf : (%1: extern vdprintf : (opaque@ (i32 <-: (i32 (@ i8) (mutable@ <struct __va_list_tag>)))))
extern : dprintf : (%1: extern dprintf : (opaque@ (i32 <-: (i32 (@ i8) ...))))
extern : fscanf : (%1: extern fscanf : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) (@ i8) ...))))
extern : scanf : (%1: extern scanf : (opaque@ (i32 <-: ((@ i8) ...))))
extern : sscanf : (%1: extern sscanf : (opaque@ (i32 <-: ((@ i8) (@ i8) ...))))
extern : vfscanf : (%1: extern vfscanf : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) (@ i8) (mutable@ <struct __va_list_tag>)))))
extern : vscanf : (%1: extern vscanf : (opaque@ (i32 <-: ((@ i8) (mutable@ <struct __va_list_tag>)))))
extern : vsscanf : (%1: extern vsscanf : (opaque@ (i32 <-: ((@ i8) (@ i8) (mutable@ <struct __va_list_tag>)))))
extern : fgetc : (%1: extern fgetc : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : getc : (%1: extern getc : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : getchar : (%1: extern getchar : (opaque@ (i32 <-: ())))
extern : getc_unlocked : (%1: extern getc_unlocked : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : getchar_unlocked : (%1: extern getchar_unlocked : (opaque@ (i32 <-: ())))
extern : fgetc_unlocked : (%1: extern fgetc_unlocked : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : fputc : (%1: extern fputc : (opaque@ (i32 <-: (i32 (mutable@ <struct _IO_FILE>)))))
extern : putc : (%1: extern putc : (opaque@ (i32 <-: (i32 (mutable@ <struct _IO_FILE>)))))
extern : putchar : (%1: extern putchar : (opaque@ (i32 <-: (i32))))
extern : fputc_unlocked : (%1: extern fputc_unlocked : (opaque@ (i32 <-: (i32 (mutable@ <struct _IO_FILE>)))))
extern : putc_unlocked : (%1: extern putc_unlocked : (opaque@ (i32 <-: (i32 (mutable@ <struct _IO_FILE>)))))
extern : putchar_unlocked : (%1: extern putchar_unlocked : (opaque@ (i32 <-: (i32))))
extern : getw : (%1: extern getw : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : putw : (%1: extern putw : (opaque@ (i32 <-: (i32 (mutable@ <struct _IO_FILE>)))))
extern : fgets : (%1: extern fgets : (opaque@ ((mutable@ i8) <-: ((mutable@ i8) i32 (mutable@ <struct _IO_FILE>)))))
extern : __getdelim : (%1: extern __getdelim : (opaque@ (i64 <-: ((mutable@ (mutable@ i8)) (mutable@ u64) i32 (mutable@ <struct _IO_FILE>)))))
extern : getdelim : (%1: extern getdelim : (opaque@ (i64 <-: ((mutable@ (mutable@ i8)) (mutable@ u64) i32 (mutable@ <struct _IO_FILE>)))))
extern : getline : (%1: extern getline : (opaque@ (i64 <-: ((mutable@ (mutable@ i8)) (mutable@ u64) (mutable@ <struct _IO_FILE>)))))
extern : fputs : (%1: extern fputs : (opaque@ (i32 <-: ((@ i8) (mutable@ <struct _IO_FILE>)))))
extern : puts : (%1: extern puts : (opaque@ (i32 <-: ((@ i8)))))
extern : ungetc : (%1: extern ungetc : (opaque@ (i32 <-: (i32 (mutable@ <struct _IO_FILE>)))))
extern : fread : (%1: extern fread : (opaque@ (u64 <-: ((opaque@ void) u64 u64 (mutable@ <struct _IO_FILE>)))))
extern : fwrite : (%1: extern fwrite : (opaque@ (u64 <-: ((opaque@ void) u64 u64 (mutable@ <struct _IO_FILE>)))))
extern : fread_unlocked : (%1: extern fread_unlocked : (opaque@ (u64 <-: ((opaque@ void) u64 u64 (mutable@ <struct _IO_FILE>)))))
extern : fwrite_unlocked : (%1: extern fwrite_unlocked : (opaque@ (u64 <-: ((opaque@ void) u64 u64 (mutable@ <struct _IO_FILE>)))))
extern : fseek : (%1: extern fseek : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) i64 i32))))
extern : ftell : (%1: extern ftell : (opaque@ (i64 <-: ((mutable@ <struct _IO_FILE>)))))
extern : rewind : (%1: extern rewind : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>)))))
extern : fseeko : (%1: extern fseeko : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) i64 i32))))
extern : ftello : (%1: extern ftello : (opaque@ (i64 <-: ((mutable@ <struct _IO_FILE>)))))
extern : fgetpos : (%1: extern fgetpos : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) (mutable@ <struct _G_fpos_t>)))))
extern : fsetpos : (%1: extern fsetpos : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) (@ <struct _G_fpos_t>)))))
extern : clearerr : (%1: extern clearerr : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>)))))
extern : feof : (%1: extern feof : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : ferror : (%1: extern ferror : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : clearerr_unlocked : (%1: extern clearerr_unlocked : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>)))))
extern : feof_unlocked : (%1: extern feof_unlocked : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : ferror_unlocked : (%1: extern ferror_unlocked : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : perror : (%1: extern perror : (opaque@ (void <-: ((@ i8)))))
extern : sys_nerr : PureCast$fepahewil:(mutable& i32)
extern : sys_errlist : PureCast$gusogonuk:(mutable& (array (@ i8)))
extern : fileno : (%1: extern fileno : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : fileno_unlocked : (%1: extern fileno_unlocked : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : popen : (%1: extern popen : (opaque@ ((mutable@ <struct _IO_FILE>) <-: ((@ i8) (@ i8)))))
extern : pclose : (%1: extern pclose : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : ctermid : (%1: extern ctermid : (opaque@ ((mutable@ i8) <-: ((mutable@ i8)))))
extern : flockfile : (%1: extern flockfile : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>)))))
extern : ftrylockfile : (%1: extern ftrylockfile : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : funlockfile : (%1: extern funlockfile : (opaque@ (void <-: ((mutable@ <struct _IO_FILE>)))))
extern : __uflow : (%1: extern __uflow : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>)))))
extern : __overflow : (%1: extern __overflow : (opaque@ (i32 <-: ((mutable@ <struct _IO_FILE>) i32))))
#+end_example

*** Other Libraries

TODO: update to a simpler example and explain shared library and
search paths etc.

This works for standard libraries. But what about vendored libraries?

Here is a minimal example for loading the cross-platform windowing
etc. library GLFW:

#+begin_src scopes :tangle _bin/externc_glfw.sc
  let glfw =
      include
          "GLFW/glfw3.h"
          options
              # "-v"
              .. "-I" module-dir "/../_guix/dev/dev/include"

  let glfw-lib-path = (.. module-dir "/../_guix/dev/dev/lib/libglfw.so")

  load-library glfw-lib-path

  run-stage;
  glfw.extern.glfwInit;
#+end_src

Here we have to add some options to the ~include~ function for the
path to search for include files. These options correspond to what the
clang compiler would expect from the command line.

In this example we installed the packages using the ~guix~ package
manager in the ~_guix/dev/dev~ directory.

 ~module-dir~ gives the current directory of the module that is
 executing and doesn't include a trailing slash.

*** Calling Scopes Code from C

TODO


** References, Ownership, and Storage

TODO

See:
https://gist.github.com/radgeRayden/67b654b5bb8f3227749b5dd7a577ec4d


*** defer

Not really a feature in C++ but more from the Go family.

#+begin_src scopes
  defer print "end of module"

  let name = "Bob"

  defer print (.. "Goodbye " name "!")
#+end_src

#+RESULTS:
: Goodbye Bob!
: end of module

** Creating Your Own Types

TODO: write introduction

*** Creating & Extending Types

Types are typically created using the ~type~ (or the older but still
usable ~typedef~) syntax.

The simplest usage is just to define a type:

#+begin_src scopes
  type NewType

  print NewType
  print (typeof NewType)
#+end_src

#+RESULTS:
: NewType
: type

In addition to creating completely new types you can subtype others.

For instance you can make a subtype of integers using the ~integer~
supertype:

#+begin_src scopes
  type NewInt < integer

  print (typeof NewInt)
#+end_src

#+RESULTS:

There is a use for standalone types like this, but they are limited
and not likely the first thing you would be interested. Typically you
will want them to be instantiated and contain some data.

In order to actual use instantied types to hold data we can specify a
"storage" type.

The storage type of a type or value can be retrieved with the
~storageof~ function:

#+begin_src scopes
  print "storageof i32" (storageof i32)
  print "storageof f32" (storageof f32)

  # INVALID for abstract types
  # (storageof integer)
  # (storageof real)
#+end_src

#+RESULTS:
: storageof i32 i32
: storageof f32 f32

The reason for this is that the logical types really only exist at
compile time and its just to help us not make some mistakes. So to
actually have some data we need a storage type that corresponds to
actual bytes on the machine. We will discuss this in more detail later
but we will show a simplistic example:

#+begin_src scopes
  type MyInt : i32

  print (storageof MyInt)
#+end_src

#+RESULTS:
: i32

You can always cast a type to the storage type associated with it
using ~storagecast~:

#+begin_src scopes
  type MyInt : i32

  print (storagecast MyInt)
#+end_src

#+RESULTS:
: $felodasut:(opaque@ _type)

This definition will create a so-called "plain" type. We will discuss
plain vs "unique" types later but briefly the unique variants of these
type definitions are written with ~::~ rather than ~:~.


#+begin_src scopes
  type MyUniqueInt :: i32

  print (storageof MyUniqueInt)
#+end_src

#+RESULTS:
: i32

We still can't actually instantiate/construct a value for this type
because we have no constructor. If you attempt to you will get an
error indicating this.

We can write constructors (as we will see below) but a very common
pattern will be to simply subtype from a type that already has a
constructor. Subtyping is achieved by an additional ~<~ section in the
~type~ syntax:


#+begin_src scopes
  type MyInt < integer : i32
  print (storageof MyInt)

  let i = (MyInt 2)

  print i

  print (typeof i)
  print (storageof i)

  print (storagecast i)
#+end_src

#+RESULTS:
: i32
: 2:MyInt
: MyInt
: i32
: 2

The ~integer~ type is the supertype of all the concrete integer
(e.g. ~i32~, ~u8~, etc.). You can find the supertypes of existing
types with the ~superof~ function:

#+begin_src scopes
  print "superof i32" (superof i32)
  print "superof f32" (superof f32)
#+end_src

#+RESULTS:
: superof i32 integer
: superof f32 real

Using this knowledge we can write our type definition more simply as:

#+begin_src scopes
  type MyInt <: i32

  print (storageof MyInt)

  let i = (MyInt 2)

  print i

  print (typeof i)
  print (storageof i)

#+end_src

#+RESULTS:
: i32
: 2:MyInt
: MyInt
: i32

Where the type of the new type will be subtyped from ~(superof i32)~
and the storage will be ~(storageof i32)~.

The same pattern holds for unique types:

#+begin_src scopes
  type UniqueInt1 < integer :: i32

  type UniqueInt2 <:: i32
#+end_src

#+RESULTS:

**** Subtyping Struct Types

Oftentimes we want to define a struct with methods etc. We can do this
by subtyping from struct. However with the normal ~type~ syntax we
cannot list the fields of the struct easily. So the ~struct~ syntax
provides a subtyping syntax that allows us to define a new type that
is backed by a struct of your chosen fields.

#+begin_src scopes
  using import struct
  using import String

  type Animal < Struct

  struct Dog < Animal
      color : String
      bark : String
      height : f32
      length : f32

  let dog =
      Dog
          "yellow"
          "woof woof"
          34
          89
  ;
#+end_src

#+RESULTS:

*** Methods

Similar to C++ classes and (what is called) Object-Oriented
Programming types can have method functions on them.

#+begin_src scopes
  type MyInt <: i32

      fn yell (self)
          print "hello"

  let i = (MyInt 2)

  'yell i
#+end_src

#+RESULTS:
: hello

In this example we add a method to our new subtype that simply prints
something.

We can see that the Python convention of explicitly writing out the
~self~ argument to the function is followed. The ~self~ variable can
be used to access data from the instantiated object:

#+begin_src scopes
  type MyInt <: i32

      fn yell (self)
          print "hello" self

  let i = (MyInt 2)


  'yell i
#+end_src

#+RESULTS:
: hello 2:MyInt

In this case since ~MyInt~ is a direct subtype of an integer that we
can use it directly and the representation is close to the builtin one
for an integer type.

---

We can also declare class methods by simply calling a method on a
class without instantiating it:

#+begin_src scopes
  type MyInt <: i32

      inline yell (cls)
          print "hello" cls

  'yell MyInt

  let i = (MyInt 2)

  'yell i
  ;
#+end_src

#+RESULTS:
: hello MyInt
: hello 2:MyInt

Notice that this is an ~inline~ function so that the ~cls~ value can
remain constant.

Notice that you can still call the method on the instance. However, by
convention it seems like a good idea to distinguish class methods by
using the Python convention of calling the first argument ~cls~ (for
class) as opposed to ~self~.

**** Struct methods

Structs can also have methods defined on them and can inherit them
from super types.

#+begin_src scopes
  using import struct
  using import String

  type Animal < Struct

      fn get-area (self)
          self.height * self.length

  struct Dog < Animal
      color : String
      bark : String
      height : f32
      length : f32

      fn bark! (self)
          print self.bark

  let dog =
      Dog
          "yellow"
          "woof woof"
          34
          89

  'bark! dog
  print ('get-area dog)

  ;
#+end_src

*** Metamethods & Operator Overload

Similar to Python types support the idea of metamethods (called magic
methods in Python) which are special methods that when implemented can
be used in a protocol for various kinds of tasks.

Metamethods are methods that start with a double underscore. The
metamethod symbol must match the corresponding operators.

You can define them just like methods otherwise. Here we are are
redefining the ~repr~ of our type:

#+begin_src scopes
  type MyInt <: i32

      fn __repr (self)
          "MyInt"

  let i = (MyInt 2)

  print (repr i)
#+end_src

#+RESULTS:
: MyInt

**** Operator Metamethods

We can also redefine operators as well, however these are a bit more
complicated since we need to dispatch on the types.

These dispatching functions typically require then returning an inline
function corresponding to the correct type signature.

In this example we are re-implementing the ~+~ operator by comparing
the types of the inputs, ensuring they are the same, and then
returning an inline that casts to the types underlying storage type
and using the builtin operator for that storage type.

#+begin_src scopes
  type MyInt <: i32

      inline __+ (lhs_type rhs_type)
          static-if (lhs_type == rhs_type)
              inline (a b)
                  (storagecast a) + (storagecast b)

  let i = (MyInt 2)
  let j = (MyInt 3)

  print (i + j)

#+end_src

#+RESULTS:
: 5


Notice that we are using ~static-if~ in this dispatch because this
should happen statically at all the call-sites.

Its a little complicated at first but obviously very powerful and a
lot simpler than other compile-time dispatch systems like template
metaprogramming.


**** List of Metamethods

| Metamethod | Operator | Generic? | Description                                  |
|------------+----------+----------+----------------------------------------------|
| ~__repr~   | ~repr~   | no       | Generate a string representation of a value. |
| ~__+~      | ~+~      | yes      | Add two values.                              |


*** Constructors & Destructors

TODO

*** Properties

*** Modifying Existing Types

Another interesting feature is the ability to modify types in any
location.

This lets you add behavior to a type defined in a library or just
split up your own definitions if you are doing something fancy.

To do this we use the ~type+~ syntax:

#+begin_src scopes

  type MyInt <: i32

  # end of initial type definition


  # somewhere else in your code...
  type+ MyInt
      fn yell (self)
          print "hello" self


  let i = (MyInt 2)
  'yell i
#+end_src

#+RESULTS:
: hello 2:MyInt

This is a very useful alternative to constantly subtyping or using
multiple inheritance to get complex types.

** Debugging


#+begin_src scopes
  fn add (a b)
      dump a b
      a + b

  add 3 4
#+end_src

#+RESULTS:

#+begin_src scopes
  let a = 3

  report a

  print a
#+end_src


** Other Cool & Useful Constructs & Routines
*** I/O

Currently low level I/O is handled using the C standard libraries (or
whatever other library you want).

Some tips though for interfacing with them.

#+begin_src scopes
  using import String
  import C.stdio

  let input-prompt = ">"
  let result-prompt = "==>"

  # display a prompt
  (C.stdio.fputs "> " C.stdio.stdout)

  # allocate a C-array for collecting input
  local input = ((array i8 2048))

  # get input from stdin
  (C.stdio.fgets input 2048 C.stdio.stdin)

  # then convert to a string
  let input-str = (String (& input) (countof input))

  print (result-prompt input-str)
#+end_src
*** String Formatting

TODO

*** Dynamic Dispatch

#+begin_src scopes
  using import enum
  enum State
      a : StateA
      b : StateB

  local curState : State = (State.a (StateA))
  # now when you deal with states, you do this:
  dispatch curState
  case a ()
      'init a
  case b ()
      'init b
  default
      ;

  # there's a shorthand for doing the same thing with all fields of an enum:
  'apply curState
      inline (T self)
          'init self
#+end_src
*** Expression Chaining
TODO

*** Function Chaining
TODO

*** itertools

TODO

*** Run Time Closures: Captures

TODO

*** Box

*** Rc
