* Level 2: Things you would know if you knew C/C++

** structs

Here is a basic example of using a struct:

#+begin_src scopes
  using import struct

  struct Example
      value : i32
      choice = false
      text : string = ""

  # There are two ways to construct a value:

  # 1. C-ish looking declaration
  local example : Example
      value = 100
      text = "test"

  # 2. Assignment "scopes-style"
  local example =
      Example
          value = 100
          text = "test"

  print example.value
  print example.text
#+end_src

#+RESULTS:
: 100
: test


#+begin_src scopes
  using import struct

  struct thing
      what : string

  let t = (thing (what = "test"))

  print t.what
#+end_src

#+RESULTS:
: test

#+begin_src scopes
  using import struct

  struct thing
      what : string
      size : u32

  let t =
      thing
          "Other thing"
          1:u32

  print t.what
  print t.size

  let d =
      thing
          size = 1:u32
          what = "Other thing"

  print d.what
  print d.size
#+end_src

#+RESULTS:
: Other thing
: 1:u32
: Other thing
: 1:u32


** Types

#+begin_src scopes
  print (typeof 'print)
  print (storageof Symbol)
  print (storagecast 'print)
#+end_src

#+RESULTS:
: Symbol
: u64
: 4809770749102710031:u64

** Const

#+begin_src scopes
  print (constant? 1)
  local a = 1
  print (constant? a)
#+end_src

#+RESULTS:
: true
: false

** Type Annotations

The return values of functions can be explicitly typed, and will be
type-checked:

#+begin_src scopes :tangle _bin/functions_returns.sc
  fn get-origin ()
      returning (_: i32 i32)

      _ 0 0

  let a b  = (get-origin)

#+end_src

#+RESULTS:

The ~returning~ statement can occur anywhere in the function
block. Types will not be cast and the annotation will be strictly
checked.


** dump

#+begin_src scopes
  fn add (a b)
      dump a b
      a + b

  add 3 4
#+end_src

#+RESULTS:

** TODO Operator Overload

** C-like Strings


#+begin_src scopes :tangle _bin/primitives_strings_extractvalue.sc
  let digits = "0123456789"

  print (digits @ 1)
#+end_src

#+RESULTS:
: 49:i8

Where the value is the int value for the char it encodes.

** TODO More Strings

** TODO Arrays

First we must talk about the C-style arrays.

#+begin_src scopes
  let arr = ((array f32 2) 0 1)
  print arr
#+end_src

#+RESULTS:
: (arrayof f32 0.0 1.0)


#+begin_src scopes
  let arr = (arrayof f32 0 1 2 3)

  print arr
#+end_src

#+RESULTS:
: (arrayof f32 0.0 1.0 2.0 3.0)


#+begin_src scopes
  let arr = (arrayof f32 0 1 2 3)

  print (arr @ 1)
#+end_src

#+RESULTS:
: 1.0

Array of structs

#+begin_src scopes
  using import struct

  struct Dog
      name : string
      bark : string = "woof"
      height : f32

  let d0 =
      Dog
          "Fido"
          "Bow! Wow!"
          43

  let d1 =
      Dog
          "Max"
          "Wong! Wong!"
          56

  # array type can't be accessed with dynamically generated indices
  # (like from the for loop below) because you could easily go beyond
  # the bounds of the array
  local dogs = (arrayof Dog d0 d1)

  for idx in (range 2)
      # access the struct members of the array elements
      print ((dogs @ idx) . name) "says" ((dogs @ idx) . bark)

  for idx in (range 2)
      # access the struct members of the array elements
      ((dogs @ idx) . name) = "George"

      print ((dogs @ idx) . name)


  local dog-arr = (array Dog 2)
  for i in (range 2)
      (dog-arr @ i) =
          Dog
              "Max"
              "Wong! Wong!"
              56

#+end_src

#+RESULTS:


** Tuples

In Level 1 we saw how to dynamically define tuples with ~tupleof~. You
can also declare the type in full first before instantiating.

#+begin_src scopes

  print
      ((tuple i32 f32) 0:i32 1:f32)
#+end_src

#+RESULTS:
: (tupleof 0 1.0)

#+begin_src scopes
  let tup-type = (tuple (a = i32) (b = u64))

  print (tup-type (a = 0) (b = 1:u64))
#+end_src

#+RESULTS:
: (tupleof 0 1:u64)

** Including C Functions

You can load a single function:

#+begin_src scopes :tangle _bin/externc1.sc
  let printf =
      do
          let header = (include "stdio.h")
          header.extern.printf

  printf "hello\n"
#+end_src


Or a whole module:

#+begin_src scopes :tangle _bin/externc2.sc
  let c:stdio =
      (include "stdio.h") . extern

  c:stdio.printf "hello\n"
#+end_src

Note that ~c:stdio~ is just a symbol and not special syntax. It could
have been: ~stdio~ or any other valid symbol.


If you have a newer version it is also included in the standard
library:

#+begin_src scopes :tangle _bin/externc2.sc
  let c:stdio = (import C.stdio)
  let c:string = (import C.string)
  let c:stdlib = (import C.stdlib)
#+end_src


** Non-standard Libraries

This works for standard libraries. But what about vendored libraries?

Here is a minimal example for loading the cross-platform windowing
etc. library GLFW:

#+begin_src scopes :tangle _bin/externc_glfw.sc
  let glfw =
      include
          "GLFW/glfw3.h"
          options
              # "-v"
              .. "-I" module-dir "/../_guix/dev/dev/include"

  let glfw-lib-path = (.. module-dir "/../_guix/dev/dev/lib/libglfw.so")

  load-library glfw-lib-path

  run-stage;
  glfw.extern.glfwInit;
#+end_src

Here we have to add some options to the ~include~ function for the
path to search for include files. These options correspond to what the
clang compiler would expect from the command line.

In this example we installed the packages using the ~guix~ package
manager in the ~_guix/dev/dev~ directory.

 ~module-dir~ gives the current directory of the module that is
 executing and doesn't include a trailing slash.





** defer

Not really a feature in C++ but more from the Go family.

#+begin_src scopes
  defer print "end of module"

  let name = "Bob"

  defer print (.. "Goodbye " name "!")
#+end_src

#+RESULTS:
: Goodbye Bob!
: end of module

** Ownership and the Borrow Checker

See:
https://gist.github.com/radgeRayden/67b654b5bb8f3227749b5dd7a577ec4d

Namely remember when making small snippets that you can't return
unique values from a module.

** TODO COMMENT

- [ ] pointers and references
- [ ] constant values
- [ ] defer
