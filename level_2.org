* Level 2: Things you would know if you knew C/C++

** structs

Here is a basic example of using a struct:

#+begin_src scopes
  using import struct

  struct Example
      value : i32
      choice = false
      text : string = ""

  # There are two ways to construct a value:

  # 1. C-ish looking declaration
  local example : Example
      value = 100
      text = "test"

  # 2. Assignment "scopes-style"
  local example =
      Example
          value = 100
          text = "test"

  print example.value
  print example.text
#+end_src

#+RESULTS:
: 100
: test


#+begin_src scopes
  using import struct

  struct thing
      what : string

  let t = (thing (what = "test"))

  print t.what
#+end_src

#+RESULTS:
: test

#+begin_src scopes
  using import struct

  struct thing
      what : string
      size : u32

  let t =
      thing
          "Other thing"
          1:u32

  print t.what
  print t.size

  let d =
      thing
          size = 1:u32
          what = "Other thing"

  print d.what
  print d.size
#+end_src

#+RESULTS:
: Other thing
: 1:u32
: Other thing
: 1:u32


** Types

#+begin_src scopes
  print (typeof 'print)
  print (storageof Symbol)
  print (storagecast 'print)
#+end_src

#+RESULTS:
: Symbol
: u64
: 4809770749102710031:u64

** Const

#+begin_src scopes
  print (constant? 1)
  local a = 1
  print (constant? a)
#+end_src

#+RESULTS:
: true
: false

** Type Annotations

The return values of functions can be explicitly typed, and will be
type-checked:

#+begin_src scopes :tangle _bin/functions_returns.sc
  fn get-origin ()
      returning (_: i32 i32)

      _ 0 0

  let a b  = (get-origin)

#+end_src

#+RESULTS:

The ~returning~ statement can occur anywhere in the function
block. Types will not be cast and the annotation will be strictly
checked.


** dump

#+begin_src scopes
  fn add (a b)
      dump a b
      a + b

  add 3 4
#+end_src

#+RESULTS:

** TODO Operator Overload

** C-like Strings


#+begin_src scopes :tangle _bin/primitives_strings_extractvalue.sc
  let digits = "0123456789"

  print (digits @ 1)
#+end_src

#+RESULTS:
: 49:i8

Where the value is the int value for the char it encodes.

** TODO More Strings

** TODO Arrays

*** C-style Arrays

First we must talk about the C-style arrays.

#+begin_src scopes
  let arr = ((array f32 2) 0 1)
  print arr
#+end_src

#+RESULTS:
: (arrayof f32 0.0 1.0)


#+begin_src scopes
  let arr = (arrayof f32 0 1 2 3)

  print arr
#+end_src

#+RESULTS:
: (arrayof f32 0.0 1.0 2.0 3.0)


#+begin_src scopes
  let arr = (arrayof f32 0 1 2 3)

  print (arr @ 1)
#+end_src

#+RESULTS:
: 1.0

Array of structs

#+begin_src scopes
  using import struct

  struct Dog
      name : string
      bark : string = "woof"
      height : f32

  let d0 =
      Dog
          "Fido"
          "Bow! Wow!"
          43

  let d1 =
      Dog
          "Max"
          "Wong! Wong!"
          56

  # array type can't be accessed with dynamically generated indices
  # (like from the for loop below) because you could easily go beyond
  # the bounds of the array
  local dogs = (arrayof Dog d0 d1)

  for idx in (range 2)
      # access the struct members of the array elements
      print ((dogs @ idx) . name) "says" ((dogs @ idx) . bark)

  for idx in (range 2)
      # access the struct members of the array elements
      ((dogs @ idx) . name) = "George"

      print ((dogs @ idx) . name)


  local dog-arr = (array Dog 2)
  for i in (range 2)
      (dog-arr @ i) =
          Dog
              "Max"
              "Wong! Wong!"
              56

#+end_src

#+RESULTS:

*** Arrays

#+begin_src scopes
  using import Array

  # Fixed size array
  local arr = ((Array i32 10))
  print (typeof arr)

  # Growing array (e.g. C++ vector)
  local arr = ((Array i32))
  print (typeof arr)

  # You can explicitly use GrowingArray or FixedArray types
  local garr = ((GrowingArray i32))
  local farr = ((FixedArray i32 10))

  # add a value to the array
  let element = ('append arr 0)

  print element

  print (countof arr)
  print (arr @ 0)

  # assign to a particular location
  arr @ 0 = 2
  print (arr @ 0)

  # TODO
  # insert values in between
  # 'append arr 4
  # 'insert arr 1 3

  print "last:" ('last arr)
  print "pop:" ('pop arr)

  # WARNING: segfault, no last element
  # print "last:" ('last arr)

  # remove
  'append arr 0
  'append arr 1

  'remove arr 0

  print arr

  # you can swap values
  print "Before Swap"

  'append arr 0
  print (arr @ 0)
  print (arr @ 1)

  print "After Swap"
  'swap arr 0 1

  print (arr @ 0)
  print (arr @ 1)

  # # reverse
  # print "reverse"

  # arr = ('reverse arr)
  # print (arr @ 0)
  # print (arr @ 1)

  # # sort
  # print "sort"
  # 'sort arr
  # print (arr @ 0)
  # print (arr @ 1)


  # remove all values in the array
  'clear arr
  print (countof arr)

  # WARNING: segfault if you try to access values that aren't there
  #
  # arr @ 0

  # get the capacity of the array, when this is exceeded it will be
  # expanded
  print "capacity:" ('capacity arr)

  # add capacity + 1 elements
  for i in (range 5)
      'append arr i

  # capacity is expanded
  print "capacity:" ('capacity arr)

  # again
  for i in (range 6)
      'append arr (i + 5)
  print "capacity:" ('capacity arr)

  # etc.

  # fixed arrays have the capacity you give them
  local arr = ((Array i32 10))

  print "capacity:" ('capacity arr)


  # You can use 'resize' or 'reserve' to force a particular capacity

  # resize will initialize the elements
  print "resize"

  local arr = ((Array i32))

  print "capacity:" ('capacity arr)
  print "countof:" (countof arr)
  'resize arr 10
  print "capacity:" ('capacity arr)
  print "countof:" (countof arr)

  print (arr @ 0)

  # reserve will not initialize the elements

  print "reserve"
  local arr = ((Array i32))

  print "capacity:" ('capacity arr)
  print "countof:" (countof arr)
  'reserve arr 10
  print "capacity:" ('capacity arr)
  print "countof:" (countof arr)

  # WARNING: segfault, not initialized
  # print (arr @ 0)


  # casting to generators
#+end_src

#+RESULTS:

** Tuples

In Level 1 we saw how to dynamically define tuples with ~tupleof~. You
can also declare the type in full first before instantiating.

#+begin_src scopes

  print
      ((tuple i32 f32) 0:i32 1:f32)
#+end_src

#+RESULTS:
: (tupleof 0 1.0)

#+begin_src scopes
  let tup-type = (tuple (a = i32) (b = u64))

  print (tup-type (a = 0) (b = 1:u64))
#+end_src

#+RESULTS:
: (tupleof 0 1:u64)

** Including C Functions

You can load a single function:

#+begin_src scopes :tangle _bin/externc1.sc
  let printf =
      do
          let header = (include "stdio.h")
          header.extern.printf

  printf "hello\n"
#+end_src


Or a whole module:

#+begin_src scopes :tangle _bin/externc2.sc
  let c:stdio =
      (include "stdio.h") . extern

  c:stdio.printf "hello\n"
#+end_src

Note that ~c:stdio~ is just a symbol and not special syntax. It could
have been: ~stdio~ or any other valid symbol.


If you have a newer version it is also included in the standard
library:

#+begin_src scopes :tangle _bin/externc2.sc
  let c:stdio = (import C.stdio)
  let c:string = (import C.string)
  let c:stdlib = (import C.stdlib)
#+end_src


** Non-standard Libraries

This works for standard libraries. But what about vendored libraries?

Here is a minimal example for loading the cross-platform windowing
etc. library GLFW:

#+begin_src scopes :tangle _bin/externc_glfw.sc
  let glfw =
      include
          "GLFW/glfw3.h"
          options
              # "-v"
              .. "-I" module-dir "/../_guix/dev/dev/include"

  let glfw-lib-path = (.. module-dir "/../_guix/dev/dev/lib/libglfw.so")

  load-library glfw-lib-path

  run-stage;
  glfw.extern.glfwInit;
#+end_src

Here we have to add some options to the ~include~ function for the
path to search for include files. These options correspond to what the
clang compiler would expect from the command line.

In this example we installed the packages using the ~guix~ package
manager in the ~_guix/dev/dev~ directory.

 ~module-dir~ gives the current directory of the module that is
 executing and doesn't include a trailing slash.





** defer

Not really a feature in C++ but more from the Go family.

#+begin_src scopes
  defer print "end of module"

  let name = "Bob"

  defer print (.. "Goodbye " name "!")
#+end_src

#+RESULTS:
: Goodbye Bob!
: end of module

** Ownership and the Borrow Checker

See:
https://gist.github.com/radgeRayden/67b654b5bb8f3227749b5dd7a577ec4d

Namely remember when making small snippets that you can't return
unique values from a module.

** TODO COMMENT

- [ ] pointers and references
- [ ] constant values
- [ ] defer
