* Level 1: What you already know, just Scoped

In this section we will cover the concepts that are basically the same
between a scripting language like Python and Scopes.

** Printing Output

What language is complete without a print statement!

#+begin_src scopes :tangle _bin/print1.sc
  print "Hello World!"
#+end_src

The print statement takes a variable number of arguments, just like in
Python:

#+begin_src scopes :tangle _bin/print2.sc
  # print with 2 arguments
  print "Hello" "World!"
#+end_src

Here the basic string type is used. We will describe strings in more
detail later.

We also show the use of comments in the last example


** Assignment, Binding, Values & Variables

In Scopes there is an explicit distinction between variables and
values. *Variables* are names bound to a place or slot of explicit
memory that can then be mutated later, whereas *values* are immutable
once created and cannot be modified in place.

Because Scopes is a semi-functional Scheme-like language values are
more common than variables, so we describe them first in terms of the
~let~ syntax:

#+begin_src scopes :tangle _bin/assignment_let.sc
  let name = "Bob"
#+end_src

Simple enough. As we will see once we learn about expressions though
that the right hand side can be much more complex than in most
languages.

For one we can do multiple assignments in the same let block:

#+begin_src scopes :tangle _bin/assignment_let.sc
  let
      name = "Bob"
      password = "password"
      height = 6
#+end_src

#+RESULTS:

You can also do a multiple assignment like so:

#+begin_src scopes :tangle _bin/assignment_let.sc
  let a b c = 1 2 3
  print "a:" a "b:" b "c:" c
#+end_src

#+RESULTS:
: a: 1 b: 2 c: 3


Note that if you reassign a value to the same name this is not
actually mutating the first value.

#+begin_src scopes :tangle _bin/assignment_let.sc
  let count = 0
  let count = (count + 1)
#+end_src

The storage location (stack, heap, and data segment) of the value
generated from an expression is determined by the kind of expression.

You can explicitly choose stack or data-segment by using the ~local~
or ~global~ mechanisms. 

For those unaware the "stack" is a data structure used in most
programming languages that provides a fast and convenient way to store
data in nested scopes that can easily be managed and torn down without
manual memory managemeng. For example when a function goes out of
scope all of the locally defined memory values can be freed.

The heap is all the memory that is not in the stack and can
essentially be accessed in any scope as long as the layout of data is
known. This memory must be manually managed since it lacks a mechanism
like scoping rules to know when data is no longer needed.


#+begin_src scopes
  local count = 0
  print count
  count = (count + 1)
  print count
#+end_src

#+RESULTS:

In scopes there is also another location values can stored in called
the *data segment* which is an actual location in the output
binary. Therefore it is not located on either the stack or the
heap. However, because of this you must be careful not to put too
large of data because your final executable binary will have to carry
it around with it.

Global values can be defined as such.

NOTE: Currently there is a bug in scopes that causes the ~print~
command to show some gobbledy-gook like ~PureCast$halafakes~ instead
of the normal representation of the value. The following snippet shows
how to rectify this with the ~deref~ function which won't be explained
until Level 2.


#+begin_src scopes
  global count = 0
  count = (count + 1)
  print count
  print (deref count)
#+end_src

#+RESULTS:
: PureCast$fomilutop
: 1


You can unbind names by using ~unlet~:

#+begin_src scopes
  let
      a = 3
      b = 4

  unlet a
  # print a
  print b
#+end_src

#+RESULTS:
: 4


** Operators

In most Lisp/Schemes there are no "operators" in the sense of infix
notations (i.e. ~arg1 operator arg2~) and only a uniform prefix
notation (i.e. ~operator arg1 arg2~). Thus unifying operators and
functions.

For many things an infix operator is preferable because it mirrors the
common notations such as in mathematics.

In Scopes you can use both! And you can also overload operators
although we won't talk about that until Level 2.

We will take the ~+~ and ~*~ operators to demonstrate the point
(arithmetic and numbers described in detail below, but nothing here
should surprise you).

We start with an understandable arithmetic expression which is also
valid Scopes code. There is an order of operations but we write this
unambiguously for now:

#+begin_src scopes :tangle _bin/operators.sc
  (0 * 3) + (1 * (4 * 5))
#+end_src

The equivalent prefix code is:

#+begin_src scopes :tangle _bin/operators.sc
  (+ (* 0 3) (* 1 (* 4 5)))
#+end_src

One advantage of prefix code is that for infix expressions like:

#+begin_src scopes :tangle _bin/operators.sc
  1 + 2 + 3 + 4
#+end_src

You can write them more simply in a summation type notation:

#+begin_src scopes :tangle _bin/operators.sc
  (+ 1 2 3 4)
#+end_src

Functions in prefix notation are also more flexible when you get to
higher order functional programming.

*** List of Built-In Operators

| symbol     | name | function | prefix? |
|------------+------+----------+---------|
| -          |      |          |         |
| ~/~        |      |          |         |
| <<         |      |          |         |
| >>         |      |          |         |
| bitcount   |      |          |         |
| findmsb    |      |          |         |
| findlsb    |      |          |         |
| bitreverse |      |          |         |

*** COMMENT Bitwise Operators

TODO move to level 2 for these conversions

Convert an int to a bitstring

Method one of converting a u32 int to a bitstring. This has potential
problems and is more operations.

#+begin_src scopes
  using import String

  let n = 8

  local bits = (String 32)

  for k in (range 32)
      let mask = (1 << k)
      let masked_n = (n & mask)
      let the-bit = (masked_n >> k)
      'append bits (tostring the-bit)

  print bits
#+end_src

#+RESULTS:
: 00010000000000000000000000000000


A better way of doing this, but requires using a u32

#+begin_src scopes

  using import String

  let n = 8:u32

  local bits = (String 32)

  for k in (range 32:u32)
      let bit = ((n >> k) & 1)
      'append bits (tostring bit)

  print bits

#+end_src

#+RESULTS:
: 00010000000000000000000000000000


Function to do this:

#+begin_src scopes
  using import String

  fn reverse-string (str)

      local revstr = (String)
      for char in ('reverse (String str))
          'append revstr char

      (tostring revstr)

  print (reverse-string "hello")

  fn u32_to_bitstring (n)
      local bits = (String 32)

      for k in (range 32:u32)
          let bit = ((n >> k) & 1)
          'append bits (tostring bit)

      return (reverse-string (tostring bits))

  # for i in (range 10:u32)
  #     print (.. (tostring i) ": " (u32_to_bitstring i))

  print (u32_to_bitstring 8:u32)
  print (u32_to_bitstring (~ 8:u32))

#+end_src

#+RESULTS:
: olleh
: 00000000000000000000000000001000
: 11111111111111111111111111110111

** Primitives & Simple Expressions

*** Overview

Overview:

| Type                  | Type Symbols                              | Example                                          |
|-----------------------+-------------------------------------------+--------------------------------------------------|
| Boolean               | ~bool~                                    | ~true~, ~false~                                  |
| Integer               | ~i32~ (default), ~i8~, ~i16~, ~i64~       | ~1~, ~-4~, ~+7~, ~3:i8~, ~0x20~, ~0b01101001:i8~ |
| Unsigned Integer      | ~u8~, ~u16~, ~u32~, ~u64~                 | ~3:u64~                                          |
| Floating Point Number | ~f32~ (default), ~f64~ (double precision) | ~1.~, ~1.0~, ~3.456:f64~, ~nan~, ~inf~, ~1e12~   |
| Empty Signifier       | ~Nothing~                                 | ~none~                                           |
| Null Pointer          | ~NullType~                                | ~null~                                           |
| Fixed-lengthString    | ~string~                                  | ~"hello"~                                        |
| Lists                 | ~List~                                    | ~'()~, ~'("a" true 1)~, ~'[0 1]~, ~{3; 1 }~      |

Note that you can determine the type of a value with the ~typeof~
function:

#+begin_src scopes :tangle _bin/primitives_typeof.sc
typeof true
typeof 1
typeof 1.0
typeof none
typeof null

let hello_type = (typeof "hello")
print "string type:" hello_type

typeof 'something
typeof '()
#+end_src

Here we can see use of the 3 different primitive syntax units in SLN
notation and how they map to the primitive values in the Scopes
language.

- ~typeof~, ~true~, ~null~, ~none~, and ~'something~ are all symbols
- ~1~ and ~1.0~ are numbers
- ~"hello"~ is a string
- ~'()~ is a list

*** Special Values

There are a few special values defined in the core language:

- ~none~ :: Which signifies emptiness and uses no storage.
- ~null~ :: Which is similar to a null-pointer and is used for pointer
  comparisons.

Some interesting identities:

#+begin_src scopes
  print (typeof none)
  print (typeof null)

  let a = ()
  print (typeof a)
#+end_src

#+RESULTS:
: Nothing
: NullType
: Nothing

*** Booleans

The two primitive boolean values are given by the two symbols ~true~
and ~false~.

We have simple boolean logical operators in ~and~, ~or~, and ~not~:

#+begin_src scopes :tangle _bin/primitives_bool.sc
true and false
true or true
not true
#+end_src


Similar to Python other values can be interpreted implicitly as
booleans, however unlike in Python not all of them can do this.

#+begin_src scopes :tangle _bin/primitives_bool.sc
not 0
not 1

#+end_src


*** Primitive Strings

Strings are anything surrounded by double-quotes ~"~. As we have
already seen:

#+begin_src scopes :tangle _bin/primitives_strings.sc
  print "a string"
  typeof "stringzz"
#+end_src

Multiline strings can be given with quadruple-double-quotes and then
continued using indentation adjusted up to the column after the
quadruple-double-quotes:

#+begin_src scopes :tangle _bin/primitives_strings.sc
  """"a multiline string
      That is continued here
      Thats 4 (four) double-"quotes"
#+end_src

Note you don't need to escape the double-quotes in the block since
multiline blocks are considered "raw", unlike single line strings
where double-quotes need to be escaped:

#+begin_src scopes :tangle _bin/primitives_strings.sc
  print "The man said \"hello\""
#+end_src

Note that unlike languages like Python single quotes (~'~) cannot be used
for delimiting strings like double-quotes (~"~).


#+begin_src scopes :tangle _bin/primitives_strings.sc
  let multiline = """"a multiline string
                      That is continued here
                      Thats 4 (four) double-quotes

  print multiline
#+end_src

For instance this will raise an error:

#+begin_src scopes
  let multiline = """"a multiline string
      That is continued here
      Thats 4 (four) double-quotes
#+end_src

To join strings together you can use the ~..~ operator:

#+begin_src scopes :tangle _bin/primitives_strings.sc

  let header = ("Hello" .. " There:")

  print (header .. " Bob")
#+end_src

Or like the `+=` etc. you can concatenate and assign in a single
statement:

#+begin_src scopes
  local msg = ""

  msg ..= "Dear Scopes,\n"
  msg ..= "    Your charm is irresistable!\n\n"
  msg ..= "    Love,\n"
  msg ..= "    Rust"

  print msg
#+end_src

#+RESULTS:
: Dear Scopes,
:     Your charm is irresistable!
: 
:     Love,
:     Rust

You can get the number of characters in a string with the ~countof~
function:

#+begin_src scopes :tangle _bin/primitives_strings.sc
  let alphabet = "abcdefghijklmnopqrstuvwxyz"

  print (countof alphabet)
#+end_src

You can retrieve a particular character like this:

#+begin_src scopes
  let alphabet = "abcdefghijklmnopqrstuvwxyz"

  alphabet @ 4
  (@ alphabet 4)
#+end_src

#+RESULTS:


There are also some slice routines:

- ~slice~ :: Get characters from start to end
- ~lslice~ :: Get characters to the left of an index
- ~rslice~ :: Get characters to the right of an index

#+begin_src scopes :tangle _bin/primitives_strings.sc
  let alphabet = "abcdefghijklmnopqrstuvwxyz"

  print (slice alphabet 0 3)
  print (lslice alphabet 3)

  print (slice alphabet 3 (countof alphabet))
  print (rslice alphabet 3)
#+end_src

#+RESULTS:
: abc
: abc
: defghijklmnopqrstuvwxyz
: defghijklmnopqrstuvwxyz

One final note is that being a low-level language we will have much
more to talk about with regards to strings in Level 2 for concerns
regarding interop with C and memory allocation etc.

*** Integers & Unsigned Integers

While integers are familiar to Python programmers the family of
different types around them is unfamiliar. This is because Python
provides an idealized view of what an integer is. In lower level
languages like C/C++ and Scopes the underlying byte representation of
values is a first class concept, in order to be able to tightly
control memory usage for performant applications.

Additionally there is the concept of a signed and unsigned
integer. Using an unsigned integer frees up a bit that would normall
be taken up with information of the sign (i.e. positive or negative).

Signed integers are useful for arithmetic and numerical calculations
and unsigned integers are useful as indices and other identifiers that
you wouldn't perform arithmetic on.

Signed integers have type symbols of the form ~i<num_bits>~ and
unsigned integers of the form ~u<num_bits>~.

Where ~num_bits~ can be: ~8~, ~16~, ~32~, or ~64~.

For visual completeness:

| Num Bits | Signed | Unsigned |
|----------+--------+----------|
|        8 | ~i8~   | ~u8~     |
|       16 | ~i16~  | ~u16~    |
|       32 | ~i32~  | ~u32~    |
|       64 | ~i64~  | ~u64~    |

Numbers from SLN without a ~.~ are parsed as ~i32~ by default.

#+begin_src scopes :tangle _bin/primitives_integers.sc
  assert ((typeof 13) == i32)
#+end_src

The literal syntax for getting any type of number is the numerical
value syntax (e.g. ~3~) followed by ~:<type_symbol>~.

So that for the number ~8~ as an ~i8~ number you can write:

#+begin_src scopes :tangle _bin/primitives_integers.sc
  print 8:i8
#+end_src


*** Floating Point Numbers

Floating point numbers ("floats") are similar to integers in
syntax.

| Num Bits              | Symbol |
|-----------------------+--------|
| 32 (single precision) | ~f32~  |
| 64 (double precision) | ~f64~  |

Floats can be gotten from literals by adding a decimal notation or the
explicit annotation:

#+begin_src scopes :tangle _bin/primitives_floats.sc

  # integer
  typeof 1

  # floats
  typeof 1.
  typeof 1.0
  typeof 1:f32
  typeof 1:f64
#+end_src

~f32~ is the default for unannotated literals.

You can also use scientific notation equivalent to ~1*10^n~:

#+begin_src scopes :tangle _bin/primitives_floats.sc
  3e4
  typeof 3e4

  3e-4
  typeof 3e4
#+end_src

There are 3 special values for floating point numbers:

- ~+inf~ or ~inf~ :: positive "infinity"
- ~-inf~ :: negative "infinity"
- ~nan~ or ~-nan~ :: not a number

That have special relationships (sorry went a little crazy with all of
the combinations):

#+begin_src scopes :tangle _bin/primitives_floats.sc
  2. + inf
  2. * inf
  2. / inf
  inf / 2.

  2. // inf
  # be careful...
  inf // 2.

  2. + nan
  2. * nan
  2. / nan
  nan / 2.
  2. // nan
  # be careful...
  nan // 2.


  inf + inf
  inf * inf
  inf / inf
  inf // inf
  -inf + inf
  -inf * inf
  -inf / inf
  inf / -inf
  -inf // inf
#+end_src

The operators are described later in the arithmetic section but should
be obvious.


*** Symbols

**** Defining Symbols

A full description of symbols will have to wait until level 3 as this
is Scheme territory. However we introduce them here since they are a
primitive.

Symbols are just everything that is not a number, string, or list (or
comment).

Symbols are what you assign values to:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  let my_symbol = 0
#+end_src

Here we are using a symbol syntax compatible with most other
programming languages (in Python this is called "snake case"). However
unlike other languages symbols have much more freedom in what their
syntax is. As long as a symbol can't be parsed as a number, string,
list, or comment it will be interpreted as a symbol. Also any of the
brackets or separator symbols are not allowed in symbols
(i.e. ~#;()[]{},~ from the SLN definition).

Additionally the Scopes language adds some extra restrictions you will
notice for the ~'~ and ~`~ characters. We will see in a few places
where ~'~ (~sugar-quote~) gets used in this level, but it will be much
later that we encounter ~`~ (~spice-quote~).

That means all of the following are valid:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  let =a-Symbol+for_you~ = 0

  let @begin = "itemize"

  let * = 4
  let two+two = 4
  let 2+2 = 4

  let yes^you^can = "but should you?"

  let valid? = false
  let !!important!! = "you are under arrest"

#+end_src

However these will produce errors:

#+begin_src scopes
let 'hello = 0
let hell'o = 0
let hello' = 0

let `hello = 0
#+end_src

However the following are fine:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  let hel`lo` = 0
#+end_src

The reason for this is is so that Scopes can distinguish between the
value a symbol is bound to (like a variable name) and the structure of
the symbol itself (i.e. the characters in the symbol).

**** "Quoting" & Symbols

This is our first encounter with a concept in the Lisp/Scheme world
called "quoting".

Lets bind a value to a symbol first:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  let message = "Hello"
#+end_src

We should already understand that printing ~message~ will print the
string we assigned/bound to it:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  print message
#+end_src

However if we *quote* the ~message~ symbol we get what looks like a
string "message":

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  print 'message
#+end_src

In some sense it really is a "string" in that it is a sequence of
UTF-8 characters (with some restrictions).

We can even get the string of the symbol as a real string:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  'message as string
#+end_src

Its kind of like in English where you put quotes around a word to
signify the word itself (or in the case of "scare quotes" some other
connotation other than the typical meaning).

Just to hammer this home that it really is a string you can take the
symbol string and bind it to another symbol:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  let message-symbol-string = ('message as string)
#+end_src

Meta...

And in fact you don't even need to have assigned something to a symbol
for it to "exist":

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  print ('IHaventBeenAssignedToYet as string)
  'hello
#+end_src

This ~'~ character is called a "sugar-quote" and is used for syntax
macros. There is another kind of quote called a "spice-quote" using
the ~`~ character which works at a deeper level.

A full explanation of the implications of the sugar-quote won't be
continued until Level 3. The spice-quote will be discussed at Level 4
as it is a novel concept in Scopes.

I will leave it here that you can use the special function
~sc_parse_from_string~ to see for yourself that these special
characters are just syntax that will get expanded to concrete
functions in the language:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  sc_parse_from_string "hello"

  'hello

  sc_parse_from_string "'hello"

  ''hello

  sc_parse_from_string "''hello"

  sc_parse_from_string "`hello"

  sc_parse_from_string "'hel'lo"

#+end_src

**** Operating On Symbols

As we saw above we can cast them to strings:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  print ('newsymbol as string)
#+end_src

But we can also compare symbols like strings too:

#+begin_src scopes :tangle _bin/primitives_symbols.sc
  'newsymbol == 'newsymbol
  'newsymbol != 'othersymbol
#+end_src


*** Lists

**** Some Context

In scripting languages like Python they often provide a number of
primitive data structures like lists, tuples, and maps/dictionaries or
even sets.

These are all very high-level concepts compared to the "structs and
arrays" of low-level languages like C or C++ (without the standard
library).

Scopes aims to combine the efficiency and control of languages like
C/C++ while maintaining a relatively high-level veneer similar to
Python.

Thus the base language only provides a single seemingly-high-level
data structure called simply a list.

However, while similar in some aspects to the "list" of Python this
list is very different in implementation and behavior and actually
comes from the Scheme/Lisp heritage (LISt Processing).

Describing the full behavior of lists is a topic for Level 3 but here
we describe some ways that basic lists can be used in place of mutable
lists and maps from a language like Python.

In Level 2 we will also describe how you can get data structures that
actually behave like Python lists (i.e. linked-lists),
maps/dictionaries (i.e. hash-maps) from the standard library. Its
worth forewarning that in the vast majority of cases you will probably
want to employ these more classical data structures for performance
reasons. The lists we are discussing here are flexible in a
fundamental way but are only practically used in a specific context
that won't really be elaborated on until Level 3 when we talk about
syntax macros.

We start with defining a simple list of numbers from 0 to 5 in a few
different syntax forms:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  '(0 1 2 3 4 5)

  '(0,1,2, 3, 4 , 5)
#+end_src

Where we have the normal space delimiter, but also the comma character
which lets you elide whitespace.

The empty list can be given as:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  '()
#+end_src


Notice our friend ~sugar-quote~ (~'~) from the Symbols section. You
only need this on the outermost list when you define nested lists:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  '(0
    ("red" "blue" "green")
    ()
    10
  )
#+end_src


Note that to define sublists you do not need another ~'~ character.

**** A Quick But Necessary Tangent: Why the '?

Again this is a topic for Level 3 but I'll give you the gist here.

First try it out without the ~'~:

#+begin_example
  $0 â–º (0 1)
  <string>:1:1: in fn <string>:1
      (0 1)
  <string>:1:1: while checking expression
      (0 1)
  error: cannot call value of type i32
#+end_example

You can see that scopes is trying to call the function ~0~ on the
parameter ~1~. Thats kind of weird...

In Lisp & Scheme like languages the list is not only a data-structure
for program data like numbers, strings, etc. but it is also the data
structure in which the program itself is contained in. This property
is called homoiconicity because code and data use the same (homo)
syntax (iconicity). This basically makes it much easier to write
programs that write other programs since a function can take in a
piece of language syntax, rearrange it and output something
else. These constructs are called macros and the practice in general
is called "metaprogramming". Its also similar to how compilers like
LLVM work by getting some input intermediate representation (IR) code
and rewriting it into an optimized form.

Observe that even normal looking language syntax can also be a list if
you ~sugar-quote~ it:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  '(print "hello")
#+end_src

This is how "code is data"; although as we saw above data is not
always code.

This concept doesn't really have a good analog in most scripting
languages primarily because metaprogramming is something of a
dangerous and complex feature that requires a lot of sophistication on
the part of the programmer. And scripting languages are meant to be
simple and not too complicated for beginner to intermediate
programmers.

Don't be fooled though. Metaprogramming is an incredibly powerful
language feature that used correctly can be very useful. Scopes uses
these features extensively and so we will have to become familiar with
them. Just not now. Levels 3 and above will deal with them.

Enough metaprogramming I came here to manipulate some data!

**** List Creation & Manipulation

We have already shown a basic way to define lists manually. But you
can also do this programmatically as well. The operations are a bit
stripped down in Scheme fashion but its well known that these
operations can be the foundation for arbitrary other manipulations.

First is the cons function, which is a function taking two values, the
second of which must be a list. It then returns a new list with the
first element being the first argument and the rest of the elements
are the elements of the second (list) argument. An example helps:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  cons 0 '(0 1)
  cons '() '(0 1 2)
#+end_src

Again I won't go reeling into all the mind-expanding implications this
has here. Lets keep things grounded for now.

Normally in Lisps/Schemes they would have the additional ~car~ and
~cdr~ functions for taking lists apart. In Scopes we just have the
opposite of ~cons~; ~decons~.

#+begin_src scopes :tangle _bin/primitives_lists.sc
  decons '(0 1)
  decons '(() 0 1 2)
#+end_src

There is also a similar concatenation operator to strings:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  .. '(0 1) '(2 3)
  '(5 6) .. '(7 8)
#+end_src

Lists can also be compared for equality:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  '(0 1) == '(0 1)
  '(0) == '(1)
#+end_src

**** Some Common Listy Structures

Having only a list may seem kind of limiting; and it is in order to
maintain simplicity.

The most obvious omission is the lack of any kind of map type.

A common convention in Lisps is to encode maps in lists 2 ways:

- *plist* :: [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Property-Lists.html][Property List]]
- *alist* :: [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html][Association List]]

A plist uses an un-nested list where every two elements are
interpreted as a pair. Keys cannot be repeated (at least if you want
it to work properly):

#+begin_src scopes :tangle _bin/primitives_lists.sc
  let plist = '( 
      "bob" 10
      "suzy" 12
      "jill" 8
  )
#+end_src

This is often how keyword function arguments are implemented in
Lisp-like languages.

An alist uses a single level of nesting where key-value pairs are sub
lists of two elements:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  let alist = '( 
      ("bob" 10)
      ("suzy" 12)
      ("jill" 8)
  )
#+end_src

The more elements you have in your mapping the "better" the
datastructure you will want roughly in order of the number of
elements you have:

plist < alist < hash table

Where plists are used for very small numbers of elements (1-20). The
boundary between alists and hash tables would require some
benchmarking. If in doubt you should probably use a hash table.

I am unaware of any functions for dealing with these structures in
Scopes, but I think it helps to understand how these things are used
in practice since coming from a scripting language these kinds of
things are not used.

To add key-value pairs to a plist you could use concatenation:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  let plist = (.. '("dan" 15) plist)
#+end_src

And to add to an alist you would use cons:

#+begin_src scopes :tangle _bin/primitives_lists.sc
  let alist = (cons '("dan" 15) alist)
#+end_src






** Converting Values To Strings

You can get the implicit "stringified" version of primitives using
either ~tostring~ or ~repr~.

#+begin_src scopes
  print (tostring 10)
  print (repr 10)
#+end_src

#+RESULTS:
: 10
: 10

~tostring~ give a plain kind of string whereas ~repr~ is meant for
making it look pretty in different contexts. Here it returns the same
result as ~tostring~ but on a terminal it gives the raw string:
~"\x1b[33m10\x1b[0m"~ and when you ~print~ it you get a colored ~10~.

Note that this stringification is not meant to be a reliable
*serialization* of the values and is just meant for human inspection
like for in logs or reporting the value on the terminal.

We will see in higher levels that these two functions are hookable
similar to the Python "magic method" protocols e.g. ~__repr__~.

** TODO COMMENT Arithmetic & Mathematics

We have kind of already seen arithmetic above in the section on
Operators.



*** TODO COMMENT Special Mathematical Functions and Numbers

|   | symbol |
|---+--------|
|   | ~ln~   |
|   | ~pi~   |
|   | ~sin~  |
|   | ~cos~  |



** Basic Control Flow

*** Conditionals & Boolean Expressions

Boolean expressions are expressions which evaluate to either ~true~ or
~false~.

#+begin_src scopes :tangle _bin/conditional_bool-exprs.sc
  true and true or false

  0 > 3

  "goodbye" != "hello"
#+end_src

This can be used in combination with the familiar if-else kind of
syntax:

#+begin_src scopes :tangle _bin/conditional_bool-exprs.sc

  let valid? = true

  if valid? (print "SO TRUEE!!")


  let height = 3.3

  let MIN_HEIGHT = 4

  if (height < MIN_HEIGHT)
      print "You must be " MIN_HEIGHT "ft to ride"
  else
      print "Step aboard!"


  let color-pick = "red"

  # choose a complementary color
  let complement =
      if (color-pick == "blue")
          "yellow"

      elseif (color-pick == "red")
          "green"

      elseif (color-pick == "yellow")
          "purple"

      else
          "invalid-color"

  if (complement != "invalid-color")
      print complement "is the complement to" color-pick
  else
      print "You did not pick a primary color"


#+end_src

Some values can be implicitly interpreted as booleans:

#+begin_src scopes :tangle _bin/conditional_implicit-bool.sc
  if (not none) (print "boolable")

  if (not 0) (print "boolable")
  if 1 (print "boolable")

  if inf (print "boolable")
  if nan (print "boolable")
#+end_src

As we will see in type casting these values can be explicitly cast as
bools:

#+begin_src scopes :tangle _bin/conditional_implicit-bool.sc
  0 as bool
  1 as bool
  -1 as bool
#+end_src

~string~ and ~null~ types cannot be cast to booleans.

*** Loops

The fundamental loop in scopes is very general, but maybe not exactly
what you are used to from a langauge like Python.

Scopes does provide these comfy loops though and its very satisfying.

**** For-Loop

Here is a basic for loop like you would find in python:

#+begin_src scopes :tangle _bin/loop_range-forloop.sc
  for i in (range 10)
      print i
#+end_src


You can loop over the language level lists, but they need to be
"quoted" by placing a single apostrophe ~'~ at the beginning of the
list just like in other Scheme languages. Otherwise it will try to
call the function ~0~ on arguments ~1~ and ~2~.

#+begin_src scopes :tangle _bin/loop_forloop.sc
  for i in '(0 1 2)
      print i
#+end_src

The for-loop also supports the ~break~ and ~continue~ statements which
are similar to those in other languages.

#+begin_src scopes
  for i in (range 10)
      if (i == 1)
          print "continuing"
          continue;
      elseif (i > 2)
          print "breaking"
          break;
      else
          print "nothing"
#+end_src

#+RESULTS:
: nothing
: continuing
: nothing
: breaking

In the for-loop it doesn't make sense for ~break~ and ~continue~ to
return any values which is why they have a semicolon at the end (see
[[Defining & Calling Functions]]) but as we will see below this is
possible.

**** While-Loop

#+begin_src scopes :tangle _bin/loop_whileloop.sc
  local i = 0
  while (i < 5)
      print i
      i += 1
#+end_src

**** General Loop

The general loop has a few more requirements but is more flexible.

There should be:

1. A path to "repeat" the loop
2. A path to break out of the loop

#+begin_src scopes :tangle _bin/loop_loop-A.sc
  loop (a = 0)
      print a
      if (a < 10)
          repeat (a + 1)
      else
          break a
#+end_src


Technically the ~repeat~ is redundant and a bare value at the end of a
scope will "return" it and continue the loop.

#+begin_src scopes :tangle _bin/loop_loop-B.sc
  loop (a = 0)
      print a
      if (a < 10)
          a + 1
      else
          break a
#+end_src

You do need the break though, or it won't compile as this will always
be an infinite loop.


**** COMMENT Fold-Loop





*** TODO COMMENT Blocks

** Type Casting

You can convert types using the ~as~ operator:

#+begin_src scopes :tangle _bin/typecast_as.sc
  # constant
  0 as f32

  1.2 as i32

  -1 as u32

  # not constant
  'a-symbol as string
#+end_src

Which is a *static cast* and happens at compile time (see caveats above).

*** TODO COMMENT other casting

- ~imply~


** Functions

*** Defining & Calling Functions

As tradition in Scheme-like functional-ish programming languages there
are a variety of syntaxes for defining functions, due to them being
higher order and possible anonymous. Here we go over the equivalent
ways for defining functions to a simple language like Python.

First we can explicitly define a function with the ~fn~ syntax:

#+begin_src scopes :tangle _bin/functions_definitions.sc
  fn say-hello (name)
      print "Hello:" name

  # and call them like you would guess
  say-hello "Bob"
#+end_src

#+RESULTS:
: Hello: Bob


Functions without any arguments can be called in two ways:

#+begin_src scopes :tangle _bin/functions_definitions.sc
  fn yell ()
      print "AHHHHH!!!!"

  (yell)
  yell;
#+end_src

#+RESULTS:
: AHHHHH!!!!
: AHHHHH!!!!


*** Return Values

As in all "blocks" in scopes the last value is returned, as was seen
in the loop examples. The same is true for functions:

#+begin_src scopes :tangle _bin/functions_returns.sc
  fn gimme ()
      "that"

  print (gimme)
#+end_src

#+RESULTS:
: that

You can also use a return statement to be explicit:

#+begin_src scopes :tangle _bin/functions_returns.sc
  fn get-over ()
      return "here"

  print (get-over)
#+end_src

#+RESULTS:
: here

Scopes can perform "unpacking" in a general way similar to "tuple
unpacking" in Python using the ~_~ prefix operator. This is often used
to "forward" multiple return values from function returns, rather than
having to do the destructuring yourself.

#+begin_src scopes :tangle _bin/functions_returns.sc
  fn args ()
      _ 1 2 3

  let a b c = (args)
  print a b c
#+end_src

#+RESULTS:
: 1 2 3

You can unpack arguments for function parameters as well:

#+begin_src scopes
  fn trio (a b c)
      print a
      print b
      print c

  let args = '(0 1 2)

  trio (unpack args)

#+end_src

#+RESULTS:
: 0
: 1
: 2


*** Recursion With Functions

Recursion is achieved using ~this-function~:

#+begin_src scopes :tangle _bin/functions_recursion_01.sc
  fn rec-count (n)
      print n
      if (n > 5)
          return;
      this-function (n + 1)

  rec-count 0

#+end_src

#+RESULTS:
: 0
: 1
: 2
: 3
: 4
: 5
: 6



** Modules, Namespaces, & Scopes

Scopes provides a module system very much like python.

*** Using Modules

You can import installed libraries and use their methods such as:

#+begin_src scopes :tangle _bin/modules_import.sc
  import String
  let str = (String.String "hello")
#+end_src

Or you can dump the exported symbols (i.e. functions and variables)
into your current namespace with the ~using~ keyword:

#+begin_src scopes :tangle _bin/modules_using-import.sc
  using import String
  let str = (String "hello")  
#+end_src

You can also directly bind a loaded module to a symbol:

#+begin_src scopes :tangle _bin/modules_using-import.sc
  let string_mod = (import String)
  let str = (string_mod.String "hello")  
#+end_src


You can also do some fancier imports although they are a little
imperfect in their operation.

Firstly you can rebind particular symbols from a module to another
name using the ~from~ keyword:

#+begin_src scopes
  let myString = (from (import String) let String)

  print (myString "Hello")

  print (String "Hello")
#+end_src

#+RESULTS:
: Hello
: hello

However notice that the ~String~ is dumped into the local
namespace. To get around this we can use another (newer) syntax which
accepts keyed values for imported values:

#+begin_src scopes
  from (import String) let
      str = String

  print (typeof str)
  print (str "hello")
#+end_src

#+RESULTS:
: type
: hello

*** Writing Modules

Like in Python a module is implicitly defined for files. Unlike Python
however is that the module only "returns" or "exports" the last thing
in the file. This behavior is consistent with most other constructs in
Scopes.

However, it is a little strange at first since a module can return not
just a "module" or namespace but even single functions or values in
the simplest case.

So you can export a function like this in the file ~first_mod.sc~:

#+begin_src scopes  :tangle _bin/test_mod.sc
  fn not-exported ()
      print "I don't do anything"

  fn test()
      print "testing out the function"
#+end_src

Then import the function directly:

#+begin_src scopes :tangle _bin/modules_load-local-first-module.sc
  let test = (import .test_mod)

  test;
#+end_src

Notice that unlike the other modules we have imported or the behavior
in other languages that the module is just a single function.

Also notice that the first function ~not-exported~ is not available to
be called from the import.

If you want to export all of the symbols in module you can use the
builtin ~locals~ which is function that returns a namespace of all the
locally defined functions.

For example if you have the module in a file ~hellomod.sc~:

#+begin_src scopes :tangle _bin/hellomod.sc
  fn hello (name)
      (print "Hello" name)

  do
      let hello
      locals;
#+end_src

#+RESULTS:

And then import it like:

#+begin_src scopes :tangle _bin/modules_load-local-hello-module.sc
  let hellomod = (import .hellomod)

  hellomod.hello "Bob"
#+end_src

Lastly sometimes you can unintentionally return things from a module
(especially when writing small scripts for learning). To stop this you
can put a ~none~ at the end of a module.


#+begin_src scopes
  let a = 3
  none
#+end_src

#+RESULTS:

Or more stylistically you can call the null function ~()~:

#+begin_src scopes
  let a = 3
  ;
#+end_src

We will see in higher levels that some values cannot be returned from
modules and so we might guard the end of the module like this, rather
than raising an error.

**** do-blocks

The ~do~ block can thought of being equivalent to defining and
executing a new unnamed function.

#+begin_src scopes
  let msg = "Do the do"

  do
      print msg
#+end_src

#+RESULTS:
: Do the do

As you can see it can use values in the surrounding scope (a "closure").

But anything defined in the block is not available in the outer scope:

#+begin_src scopes
  let name = "Bob"

  do
      let other = "Alice"
      print "hello" name
      print "hello" other

  # this would raise an error
  # print other

#+end_src

#+RESULTS:
: hello Bob
: hello Alice

The ~do-let-locals~ pattern from above is a nice way to export symbols
from a module in a clean way. It should be used as the most common
convention.

You can also use this block to customize what gets exported. Much like
the ~__all__~ magic variable in Python.

#+begin_src scopes

  fn thing1 ()
      print "Thing1"

  fn thing2 ()
      print "Thing2"


  do
      let mything = thing1
      let thing2
      locals;
#+end_src


But what is ~do~ actually returning as a value?

Consider this code:

#+begin_src scopes
  let scope =
      do
          let
              x = 1
              y = "Hello"
          locals;

  print scope.x
  print scope.y

#+end_src

This is essentially the module which we made above but instead of
exporting it and using it in another module we are just using it right
away.

As the variable name suggests the do block returns a "scope", which we
will talk more about below.

**** Executing a module

Similar to the common python refrain of ~if __name__ == "__main__":~
Scopes has a similar special value that can be used to conditionally
execute code if a module is executed like ~scopes mod.sc~ rather than
being imported using ~main-module?~.

#+begin_src scopes :tangle _bin/modules_main.sc
  print "module code"

  if main-module?
      print "running tests..."
#+end_src

#+RESULTS:
: module code
: running tests...

*** Scopes

NOTE: this is a bit more of an advanced section.

We should talk about the namesake of the language ~Scope~, and what
makes it different from a module system like Python.

Python has this saying:

#+begin_quote
Namespaces are one honking great idea -- let's do more of those!
#+end_quote

Which never got taken that seriously because there is no first-class
concept of a "namespace" in Python. However, in Scopes we do have this
first-class namespace and surprisingly its called a ~Scope~.

So now you know where the name comes from.

Above we showed how to create a ~Scope~ using a ~do~ block and how
that is used to export symbols as a module for consumption in other
modules.

#+begin_src scopes
  let scope =
      do
          let
              message = "hello"
              name = "bob"
          locals;

  print (typeof scope)
  for k v in scope (print k ":" v)
#+end_src

#+RESULTS:
: Scope
: message : "hello"
: name : "bob"

This is the simplest and easiest way to construct a ~Scope~. However,
there is a more explicit API that uses the type itself.


One way is to use the ~'bind-symbols~ method:

#+begin_src scopes
  let scope =
      'bind-symbols (Scope)
          message = "hello"
          name = "Bob"

  run-stage;

  print (typeof scope)
  print scope.name
#+end_src

Note you need to do a "run stage" (with ~run-stage~ which will be
talked about much later).


In essence this is all the ~locals~ function above does except in a
convenient way just for everything in the local do-block scope. If you
want complete control over what gets exported and under what name you
are free to do so.

And you should also see that as a consumer of a ~Scope~ from another
module you also have complete control over the ~Scope~ object. We will
see where this comes in handy in cleaning up messy namespaces that are
autogenerated from parsing C header files in Level 2.


Here is an example of this building on a constructed ~Scope~:

#+begin_src scopes
  let scope =
      do
          let
              message = "hello"
              name = "bob"
              junk = "You don't want me"
          locals;

  # remove the "junk" symbol from the scope
  let new-scope =
      fold (scope = (Scope)) for k v in scope

          let name = (k as Symbol as string)

          if (name != "junk")
              'bind scope (Symbol name) v
          else
              scope

  run-stage;

  print new-scope.message

  # this is not in the scope
  # print new-scope.junk
#+end_src

#+RESULTS:
: hello

** Characters

As an addition to the primitive types above there is a useful function
for dealing with single characters.

#+begin_src scopes
  let utf8 = (import UTF-8)

  # convert a single character string literal to a char
  let char = (utf8.char32 "a")

  print (typeof char)
  print char
#+end_src

#+RESULTS:
: i32
: 97

** Exceptions, Errors, & Assertions

*** Error Propagation

Error propagation is much the same as you would expect
syntactically. You ~raise~ errors (or call the ~error~ function) and
then you can catch them with a ~try~-~except~ block.

#+begin_src scopes
  fn test-error ()
      if true
          error "WRONG!!"
      else
          print "right"

  try
      test-error;
  except (error)
      print "something bad happened"

  ;
#+end_src

#+RESULTS:
: something bad happened


You can also create your own error types and even do things with
them. This uses concepts that will be discussed in level 2 but the
basics are shown here:

#+begin_src scopes
  using import struct

  struct myException
      msg : string

  try
      raise (myException "an error occurred")
  except (e)
      print e.msg

#+end_src

#+RESULTS:
: an error occurred

**** How Errors are Different

However, because Scopes is a typed language there are some limitations
that might seem weird to a Python programmer. For instance the
following code will not even compile:

#+begin_src scopes
error "Bare error here"
;
#+end_src

#+RESULTS:

Nor will:

#+begin_src scopes
  fn test-error ()
      error "Error"

  test-error;
#+end_src

#+RESULTS:

The reason is that to maintain typing any function with an error in it
actually has the type signature dynamically modified to accomodate for
the error.

In languages like C and Odin with no exceptions (which can also be
turned off in C++) you typically have to of roll your own kind of
error handling system where you are always returning both the value
from the computation and the error itself if any. Although languages
like Odin provide a specific support for making this simpler in the
language. This article by the creator of Odin does a good job comparing the
"normal control flow" expressions to those of Python in this article:
https://www.gingerbill.org/article/2018/09/05/exceptions-and-why-odin-will-never-have-them/

The reason is complicated but ultimately comes down to performance and
lower complexity.

In the "normal control flow" approach there is no exceptional (haha
get it) behavior occuring.

However in languages like Python or C++, exceptions are implemented
using some form of GOTO. That is control flow doesn't follow the
normal path you would expect it to in your code. This is all the
"magic" it takes to be able to pass exceptions up the stack and
continue execution elsewhere.

Its not that this is bad /per se/, but it just adds an extra layer of
complexity into your code. The detractors of this kind of system have
a point which is that this kind of complex system shouldn't come stock
in a low level language like C/C++, where performance is
critical. Indeed it doesn't come as a default in C and you have to use
things like ~setjmp~ and ~longjmp~ to accomplish this kind of behavior
(or a library that does it for you). Indeed many libraries and
language features like coroutines, generators, etc. all use this to
great effect.

In some sense Scopes (and also Rust has a similar system) has the best
of both worlds in which instead of resorting to non-local control flow
errors are implemented in the type system.

You could implement non-local exceptions in Scopes the same as
coroutines but that would be a choice you could make in a specific
library or project rather than the language as a whole.

There will be more discussions of the details of the changes in type
signatures etc. in Level 2 when it is more appropriate.

*** Assertions

Scopes has the common assert function which you can use for quick
checks of boolean expressions. However, instead of (like in Python)
raising a special error when the assert value is false the program is
aborted.

For these nothing will happen:

#+begin_src scopes :tangle _bin/errors_assert.sc
  assert true

  assert (not false)

  assert (1 == 1)
#+end_src

But this will abort and dump core.

#+begin_src scopes
  assert false
#+end_src

** Data Structures

So far the only kind of datastructure we have seen is the list. We
also stressed that lists aren't really the same as lists or maps in
other languages and are really only used for either very simple
structures with small amounts of data and for implementing the (sugar)
syntax macros (a very advanced feature).

So what really are the comparable structures to lists, dicts, tuples,
and sets like in Python?

Here is where we need to come to grips with the fact that while Scopes
provides many of the comfy pleasantries of a language like Python, it
really is intended to be in the same class of languages as C/C++, Ada,
and Rust. That is underneath the scripting language like veneer Scopes
is both statically typed and "low level" in the sense that it allows
you to have complete control of your data structures.

So where in a language like Python you have built-in syntax for things
like linked lists (roughly) using ~[a, b]~, hash maps ~{'a' : 1}~, or
tuples ~(1, "hello")~. In low-level statically typed languages there
usually isn't specific syntax for any "blessed" high-level data
structures. Instead you either implement them yourselves or import
them from libraries; either the "standard library" which ships with
the language implementation or perhaps a third-party one.

You can also do this in Python with Classes, but is considered
bad-taste when the built-in types are sufficient.

The term "low-level" here is a bit ambiguous and roughly means a
language that is more-or-less similar to the C programming language in
terms of the basic datastructures that are built in to the
language. Namely *arrays* and *structs* (and unions which are much
less used).

Scopes intends to be one-to-one compatible with C programs and so has
similar built-in types. We will see much more of this in action later.

We won't talk about arrays or structs until Level 2 (since that is a
C/C++ equivalent feature); but we can skip over them to discuss some
easy to use high-level Python-like equivalents.

The above explanation was just to soften the blow of some divergence
from the Pythonic simplicity we have seen up until now.

*** Tuples

The tuple is probably the simplest of these. As such we will use it as
an example to describe general features of more complex types and
class-like constructs.

A tuple is an immutable datastructure of a fixed size which can
contain any combination of element types.

You can use the function ~tupleof~ to construct them directly:

#+begin_src scopes
  let tup = (tupleof 1 2:f32 "hello")
  print tup
#+end_src

#+RESULTS:
: (tupleof 1 2.0 "hello")

You can get the values of the tuple in a few ways.

Via unpacking:

#+begin_src scopes
  let tup = (tupleof 1 2:f32 "hello")

  let a b c = (unpack tup)

  print a b c
#+end_src

#+RESULTS:
: 1 2.0 hello

Explicitly accessing values via the ~@~ syntax:

#+begin_src scopes
  let tup = (tupleof 1 2:f32 "hello")

  print (@ tup 2)
  print (tup @ 1)
#+end_src

#+RESULTS:
: hello
: 2.0

There are two methods
#+begin_src scopes
  let tup = (tupleof (a = 1) (b = "hello"))
  print tup

  print ('emit tup 'a)
#+end_src

#+RESULTS:
: (tupleof 1 "hello")
: 1
: hello

#+begin_src scopes
  let tup = (tupleof (a = 1) (b = "hello"))

  print ('explode tup)
#+end_src

#+RESULTS:
: 1 hello


And further you can actually define values to have keys associated
with them, much like the Python ~namedtuple~:

#+begin_src scopes
  let namedtuple = (tupleof (a = 3) (b = "hello"))

  print "a" namedtuple.a
  print "b" namedtuple.b
#+end_src

#+RESULTS:
: a 3
: b hello

Here we see the first use of the "dot" notation which is also used in
Python.

But you can also use the ~@~ selector instead of the keys:

#+begin_src scopes
  let namedtuple = (tupleof (a = 3) (b = "hello"))

  print "0" (namedtuple @ 0)
  print "1" (namedtuple @ 1)
#+end_src

Before we dig into the other datastructures we will go over some of
the common patterns to all of them using the ~tuple~ as an example.

**** Mutability

If you declare a datastructure as ~local~ you can mutate the
components as long as they are the same type as in the construction or
declaration.

For an indexed structure this is:

#+begin_src scopes
  local things = (tupleof 3 "hello")

  things @ 0 = 5
  print (things @ 0)
#+end_src

#+RESULTS:
: 5

Notice that you don't need parens around the first part because of the
infix operator precedence rules, but you can add them if you like:

#+begin_src scopes
  local things = (tupleof 3 "hello")

  (things @ 0) = 5
  print (things @ 0)
#+end_src

#+RESULTS:
: 5


#+TODO: explain this part

#+begin_src scopes
  local things = (tupleof (a = 3) (b = "hello"))

  things.a = 4
  print things.a

  # NOT allowed
  # things.a = "test"
#+end_src

#+RESULTS:
: 4



#+begin_src scopes
  fn scopetest ()
      local t-inside =
          tupleof
              (a = 3)
              (b = "hello")

      print (t-inside @ 0)

      t-inside


  # This won't be mutable since it will rebind it as immutable in the
    outside scope
   
    let t-outside = (scopetest)

  local t-outside = (scopetest)

  print t-outside.a

  t-outside.a = 10

  print t-outside.a

#+end_src

#+RESULTS:
: 3
: 3
: 10


**** Attributes, Methods, and Meta-Methods

In the above examples we have used a number of recurring conventions
for retrieving and setting data using the "dot" operator or the ~@~
operator.

#+begin_src scopes
  let t = (tupleof (a = 3) (b = "hello"))

  t @ 0
  t.a
  (t . a)
  (. t a)
#+end_src

#+RESULTS:

These are implemented via the "metamethods" system which is similar to
the "magic methods" in Python.

These are protocols which can be customized by each type. This is also
how operator overload is implemented.

The only difference when compared to operator overload in other
languages is that this extends to general function-looking
metamethods.

For instance functions like ~unpack~ as we have seen above. However
these are different in that they are not infix operators like the dot
operator.

#+begin_src scopes
  let t = (tupleof (a = 3) (b = "hello"))

  (unpack t)
#+end_src

On the dot operator there are 3 different syntaxes which should be
described.

There is the "prefix" version ~(. t a)~, "infix" version ~(t . a)~,
and the "sugar" version ~t.a~.

The last one is of interest because it is actually a symbol that gets
expanded to the prefix version.

Lastly we see the use of this syntax:

#+begin_src scopes
  let t = (tupleof (a = 3) (b = "hello"))

  ('emit t)
#+end_src

#+RESULTS:

This is called the "method" syntax.

*** COMMENT Map

#+begin_src scopes
  using import Map
  using import String

  global mymap : (Map string i32)

  'set mymap "a" 3:i32

  if ('in? mymap "a")
      print ('get mymap "a")
#+end_src

#+RESULTS:


** COMMENT Generators & Iteration

** COMMENT Documentation

- [ ] Docstrings



** Other Helpful Miscellanea

TODO: move this to level 2 since it is basically the info you would
have in a C/C++ type declaration.

You can get the qualifiers of a value using the `qualifiersof`
operator. This is similar to `typeof` but with more information:

#+begin_src scopes
  let a = 2
  local b = 2

  qualifiersof a
  qualifiersof b
#+end_src

** Final Notes

*** Where are the Classes?

One of the most important features of Python is the use of defining
classes yet we haven't talked about them at all. Does Scopes have an
equivalent?

The answer is yes, and more!

The short answer to the class equivalent is in the use of structs
which we will see early on in Level 2 so just continue on to see that.

The longer answer is that because Scopes has extensive support for
metaprogramming you aren't required to use paradigms like Object
Oriented Programming and classes to organize your code and
data. Furthermore, because of this metaprogramming there are multiple
paradigms that can coexist together. So you might find that using
classes isn't actually necessary if you aren't forced to like in
Python.




** TODO COMMENT

- [X] functions
- [-] bindings
  - [X] let
  - [ ] bind
- [ ] report
- [X] do-blocks
- [X] conditionals
- [X] loops
- [X] modules
- [X] scopes
- [X] numbers
- [X] strings
- [X] Lists
- [X] Infix
  - [X] basics
- [X] dot notation
- [ ] attributes and methods
- [ ] metamethods
- [X] number formats
- [ ] copying
- [ ] splicing
- [X] exception handling
- [ ] iterators
- [ ] streams
